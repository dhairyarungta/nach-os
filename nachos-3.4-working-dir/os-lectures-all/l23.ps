%!PS-Adobe-3.0
%%Title: (l23)
%%Creator: (Microsoft Word: LaserWriter 8 8.1.1)
%%CreationDate: (9:09 Friday, April 28, 1995)
%%For: (tom)
%%Pages: 14
%%DocumentFonts: Times-Bold Times-Roman Courier
%%DocumentNeededFonts: Times-Bold Times-Roman Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%ADO_PaperArea: -31 -30 761 582
%ADO_ImageableArea: 0 0 730 552
%%EndComments
/md 141 dict def md begin
/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if
end		% md
%%EndProlog
%%BeginSetup
md begin
countdictstack
[
{%stopped
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *InputSlot Upper

%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *PageRegion LetterSmall
level2 {
		2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
	}{
		/lettersmall where {pop lettersmall} {letterR} ifelse
	} ifelse
%%EndFeature
}featurecleanup
(tom)setjob
/pT[1 0 0 -1 30 761]def/mT[1 0 0 -1 30 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Courier
/f0_1/Times-Bold :mre
/f1_1 f0_1 1.087 scf
/f1_14 f1_1 14 scf
/f1_12 f1_1 12 scf
/f2_1/Times-Roman :mre
/f3_1 f2_1 1.087 scf
/f3_12 f3_1 12 scf
/f4_1/Courier :mre
/f4_12 f4_1 12 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(tom; page: 1 of 14)setjob
%%EndPageSetup
gS 0 0 552 730 rC
60 55 :M
f1_14 sf
7.803 .78(Lecture 23: Distributed File Systems)J
60 91 :M
7.292 .729(23.0 Main Points)J
96 109 :M
f3_12 sf
4.692 .469(Examples of distributed file systems)J
96 127 :M
4.657 .466(Cache coherence protocols)J
60 181 :M
f1_14 sf
10.708 1.071(23.1 Concepts)J
96 199 :M
f3_12 sf
2.714 .271(A )J
f1_12 sf
7.357 .736(distributed file system)J
f3_12 sf
5.848 .585( provides transparent access to)J
96 217 :M
3.793 .379(files stored on a remote disk)J
96 253 :M
1.015(Themes:)A
96 289 :M
4.691 .469(Failures: what happens when server crashes, but client doesn't?)J
96 307 :M
3.846 .385(Or vice versa?)J
96 343 :M
3.492 .349(Performance => caching: use caching at both the clients and the)J
96 361 :M
5.694 .569(server to improve performance.)J
96 397 :M
3.547 .355(Cache coherence: how do we make sure each client sees most)J
96 415 :M
3.813 .381(up to date copy?)J
60 451 :M
f1_14 sf
7.438 .744(23.1 No caching)J
96 469 :M
f3_12 sf
3.972 .397(Simple approach: use RPC to forward every file system request)J
96 487 :M
4.09 .409(to remote server \(Novell Netware, Mosaic\).)J
96 523 :M
3.992 .399(Example operations: open, seek, read, write, close)J
96 559 :M
3.831 .383(Server implements each operation as it would for a local)J
96 577 :M
3.943 .394(request  and sends back result to client)J
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(tom; page: 2 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 277 205 rC
43 37 279 109 @f
43 37 380 257 @f
43 37 189 257 @f
275 114 :M
f3_12 sf
(S)S
182 260 :M
(A)S
375 260 :M
(B)S
213.5 94.5 32 34 rS
211 89 :M
(cache)S
44 12 360.5 85.5 @f
44 12 359.5 133.5 @f
-1 -1 338 136 1 1 337 84 @b
-1 -1 382 137 1 1 381 85 @b
244 108 -1 1 259 107 1 244 107 @a
300 107 -1 1 339 106 1 300 106 @a
-1 -1 200 243 1 1 269 124 @b
285 127 -1 1 371 239 1 285 126 @a
13 100 148 238 145 @k
-1 -1 195 212 1 1 235 150 @b
13 -85 -37 225 222 @k
-1 -1 229 218 1 1 265 149 @b
13 30 78 325 153 @k
328 159 -1 1 380 227 1 328 158 @a
13 213 261 352 239 @k
300 159 -1 1 350 234 1 300 158 @a
183 184 :M
(read)S
241 204 :M
(data)S
349 183 :M
(write)S
308 218 :M
(done)S
gR
gS 30 31 552 730 rC
126 310 :M
f3_12 sf
4.38 .438(Advantage: server provides consistent view of file system to)J
126 328 :M
2.575 .257(both A and B.)J
126 364 :M
4.201 .42(Problems?  Performance can be lousy:)J
126 382 :M
2.965 .297(    going over network is slower than going to local memory!)J
126 400 :M
2.592 .259(    lots of network traffic)J
126 418 :M
2.914 .291(    server can be a bottleneck -- what if lots of clients?)J
90 490 :M
f1_14 sf
6.686 .669(23.2 NFS \(Sun Network File System\))J
126 526 :M
f3_12 sf
3.882 .388(Idea: Use caching to reduce network load)J
126 562 :M
3.463 .346(Cache file blocks, file headers, etc. at both clients and servers:)J
162 580 :M
6.499 .65(client memory)J
162 598 :M
7.917 .792(server memory)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(tom; page: 3 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 277 205 rC
43 37 279 109 @f
43 37 380 257 @f
43 37 189 257 @f
275 114 :M
f3_12 sf
(S)S
182 260 :M
(A)S
375 260 :M
(B)S
213.5 94.5 32 34 rS
211 89 :M
(cache)S
44 12 360.5 85.5 @f
44 12 359.5 133.5 @f
-1 -1 338 136 1 1 337 84 @b
-1 -1 382 137 1 1 381 85 @b
244 108 -1 1 259 107 1 244 107 @a
300 107 -1 1 339 106 1 300 106 @a
-1 -1 200 243 1 1 269 124 @b
285 127 -1 1 371 239 1 285 126 @a
311.5 239.5 32 35 rS
342 254 -1 1 357 253 1 342 253 @a
228.5 240.5 32 35 rS
212 259 -1 1 227 258 1 212 258 @a
356 118 :M
(X)S
221 118 :M
(X)S
239 264 :M
(X)S
322 265 :M
(X)S
gR
gS 30 31 552 730 rC
126 310 :M
f3_12 sf
4.863 .486(Advantage: if open/read/write/close can be done locally, no)J
126 328 :M
6.357 .636(network traffic.)J
126 364 :M
4.581 .458(Issues: failures and cache consistency.)J
90 400 :M
f1_12 sf
7.31 .731(23.2.1 Motivation, part 1: Failures)J
126 436 :M
f3_12 sf
3.71 .371(What if server crashes?  Can client wait until server comes)J
126 454 :M
4.081 .408(back up, and continue as before?)J
126 490 :M
3.399 .34(1. Any data in server memory but not yet on disk can be lost.)J
126 526 :M
2.587 .259(2. Shared state across RPCs.  Ex: open, seek, read.  What if)J
126 544 :M
3.692 .369(server crashes after seek?  Then when client does "read", it will)J
126 562 :M
.59(fail.)A
126 598 :M
4.279 .428(3. Message re-tries -- suppose server crashes after it does)J
126 616 :M
3.576 .358(UNIX "rm foo", but before acknowledgment?   Message system)J
126 634 :M
3.04 .304(will retry -- send it again.  How does it know not to delete it)J
126 652 :M
3.798 .38(again?  \(Could solve this with two-phase commit protocol, but)J
126 670 :M
3.548 .355(NFS takes a more ad hoc aproach -- sound familiar?\))J
126 706 :M
4.205 .42(What if client crashes?)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(tom; page: 4 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 102 :M
f3_12 sf
3.382 .338(1. Might lose modified data in client cache)J
90 138 :M
f1_12 sf
6.852 .685(23.2.2 NFS Protocol \(part 1\): stateless)J
126 174 :M
f3_12 sf
3.576 .358(1. Write-through caching -- when a file is closed, all modified)J
126 192 :M
3.625 .362(blocks are sent immediately to the server disk.  To the client,)J
126 210 :M
3.833 .383("close" doesn't return until all bytes are stored on disk.)J
126 246 :M
3.985 .398(2. Stateless protocol -- server keeps no state about client,)J
126 264 :M
3.859 .386(except as hints to help improve performance \(ex: a cache\))J
126 300 :M
4.205 .421(Each read request gives enough information to do entire)J
126 318 :M
4.898 .49(operation - ReadAt\(inumber, position\), not Read\(openfile\).)J
126 354 :M
4.619 .462(When server crashes and restarts, can start again processing)J
126 372 :M
5.061 .506(requests immediately, as if nothing happened.)J
126 408 :M
3.842 .384(3. Operations are "idempotent": all requests are ok to repeat \(all)J
126 426 :M
3.777 .378(requests done at least once\).  So if server crashes between disk)J
126 444 :M
4.217 .422(I/O and message send, client can resend message, server just)J
126 462 :M
4.068 .407(does operation all over again.)J
126 498 :M
3.958 .396(Read and write file block are easy -- just re-read or re-write)J
126 516 :M
3.24 .324(file block -- no side effects.)J
126 552 :M
3.383 .338(What about "remove"?  NFS just ignores this -- does the)J
126 570 :M
3.864 .386(remove twice, second time returns an error if file not found.)J
126 606 :M
4.508 .451(4. Failures are transparent to client system)J
126 642 :M
3.678 .368(Is this a good idea?  What should happen if server crashes?)J
126 660 :M
3.48 .348(Suppose you are an application, in the middle of reading a file,)J
126 678 :M
5.953 .595(and server crashes?)J
126 714 :M
.582(Options:)A
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(tom; page: 5 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.762 .376(a. Hang until server comes back up \(next week\)?)J
126 120 :M
3.994 .399(b. Return an error? Problem is: most applications don't know)J
126 138 :M
4.782 .478(they are talking over the network -- we're transparent, right?)J
126 156 :M
3.261 .326(Many UNIX app's simply ignore errors!  Crash if there's a)J
126 174 :M
1.182(problem.)A
126 210 :M
3.063 .306(NFS does both options -- can select which one.  Usually, hang)J
126 228 :M
3.289 .329(and only return error if really must -- if see "NFS stale file)J
126 246 :M
4.98 .498(handle", that's why.)J
90 282 :M
f1_12 sf
7.668 .767(23.2.3 Motivation, part 2: cache consistency)J
126 318 :M
f3_12 sf
3.399 .34(What if multiple clients are sharing the same files?  Easy if)J
126 336 :M
3.33 .333(they are both reading -- each gets a copy of the file.)J
126 372 :M
3.511 .351(What if one is writing?  How do updates happen?)J
126 408 :M
3.607 .361(Remember: NFS has write-through cache policy.  If one client)J
126 426 :M
4.349 .435(modifies file, writes through to server.)J
126 462 :M
3.745 .374(How does other client find out about the change?)J
90 498 :M
f1_12 sf
6.807 .681(23.2.4 NFS protocol, part 2: weak consistency)J
126 534 :M
f3_12 sf
3.125 .312(In NFS, client polls server periodically, to check if file has)J
126 552 :M
3.743 .374(changed.  Polls server if data hasn't been checked in last 3-30)J
126 570 :M
4.986 .499(seconds \(exact timeout is tunable parameter\).)J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(tom; page: 6 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 294 205 rC
43 37 279 109 @f
43 37 380 257 @f
43 37 189 257 @f
275 114 :M
f3_12 sf
(S)S
182 260 :M
(A)S
375 260 :M
(B)S
213.5 94.5 32 34 rS
211 89 :M
(cache)S
44 12 360.5 85.5 @f
44 12 359.5 133.5 @f
-1 -1 338 136 1 1 337 84 @b
-1 -1 382 137 1 1 381 85 @b
244 108 -1 1 259 107 1 244 107 @a
300 107 -1 1 339 106 1 300 106 @a
-1 -1 200 243 1 1 269 124 @b
285 127 -1 1 371 239 1 285 126 @a
311.5 239.5 32 35 rS
342 254 -1 1 357 253 1 342 253 @a
228.5 240.5 32 35 rS
212 259 -1 1 227 258 1 212 258 @a
356 118 :M
-.764(X')A
221 118 :M
-.764(X')A
239 264 :M
-.764(X')A
322 265 :M
(X)S
13 100 148 240 134 @k
-1 -1 184 219 1 1 237 139 @b
174 166 :M
(t=0: X')S
13 28 76 316 143 @k
319 149 -1 1 385 231 1 319 148 @a
354 174 :M
(t=30: )S
354 190 :M
(X still ok?)S
13 210 258 341 229 @k
281 147 -1 1 339 224 1 281 146 @a
297 201 :M
-.764(X')A
13 -84 -36 220 227 @k
-1 -1 224 223 1 1 264 150 @b
240 203 :M
(X' on)S
240 219 :M
( disk)S
gR
gS 30 31 552 730 rC
126 310 :M
f3_12 sf
3.439 .344(Thus, when file is changed on one client, server is notified, but)J
126 328 :M
3.506 .351(other clients use old version of file until timeout.  They then)J
126 346 :M
4.218 .422(check server, and get new version.)J
126 382 :M
3.008 .301(What if multiple clients write to same file?  In NFS, can get)J
126 400 :M
4.156 .416(either version \(or parts of both\).  Completely arbitrary!)J
90 418 :M
f1_12 sf
8.589 .859(22.2.5 Sequential Ordering Constraints)J
126 436 :M
f3_12 sf
3.217 .322(Cache coherence: What should happen?  What if one CPU)J
126 454 :M
3.542 .354(changes file, and before it's done, another CPU reads file?)J
126 490 :M
4.093 .409(Note that every operation takes time: actual read could occur)J
126 508 :M
4.57 .457(anytime between when system call is started, and when)J
126 526 :M
5.372 .537(system call returns.)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(tom; page: 7 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 394 225 rC
13 156 204 442 274 @k
205 275 -1 1 437 274 1 205 274 @a
283 292 :M
f3_12 sf
(time)S
151 100 -1 1 229 99 1 151 99 @a
433 235 -1 1 511 234 1 433 234 @a
366 210 -1 1 444 209 1 366 209 @a
311 179 -1 1 389 178 1 311 178 @a
253 148 -1 1 331 147 1 253 147 @a
192 123 -1 1 270 122 1 192 122 @a
169 92 :M
(read: A)S
441 226 :M
(read:B or  C)S
366 202 :M
(read:  B or C)S
197 117 :M
(read: A or B)S
264 144 :M
(write B)S
329 173 :M
(write C)S
128 101 :M
(A)S
gR
gS 30 31 552 730 rC
126 330 :M
f3_12 sf
4.477 .448(Assume what we want is distributed system to behave exactly)J
126 348 :M
3.101 .31(the same as if all processes are running on a single UNIX)J
126 366 :M
1.252(system.)A
126 384 :M
3.502 .35(  If read finishes before write starts, then get old copy)J
126 402 :M
3.606 .361(  If read starts after write finishes, then get new copy)J
126 438 :M
3.041 .304(  Otherwise: get either new or old copy.)J
126 474 :M
4.229 .423(Similarly, if write starts before another write finishes, may get)J
126 492 :M
3.586 .359(either old or new version.  \(Hence in above diagram, non-)J
126 510 :M
3.936 .394(deterministic as to which value you end up with!\))J
126 546 :M
3.681 .368(In NFS, if read starts more than 30 seconds after write finishes,)J
126 564 :M
3.437 .344(get new copy.  Otherwise, who knows?  Could get partial update)J
90 600 :M
f1_12 sf
6.231 .623(22.2.6  NFS Summary)J
126 618 :M
f3_12 sf
1.814 .181(NFS pros & cons:)J
126 636 :M
1.816 .182(  + simple)J
126 654 :M
2.85 .285(  + highly portable)J
126 672 :M
4.079 .408(  - sometimes inconsistent)J
126 690 :M
2.75 .275(  - doesn't scale to large # of clients)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(tom; page: 8 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.719 .372(Might think NFS is really stupid, but Netscape does something)J
126 102 :M
4.179 .418(similar: caches recently seen pages, and refetches them if they)J
126 120 :M
3.038 .304(are too old.  Nothing in the WWW to help with cache coherence.)J
90 156 :M
f1_14 sf
8.378 .838(22.3 Andrew File System)J
126 174 :M
f3_12 sf
2.005 .2(AFS \(CMU, late 80's\) -> DCE DFS \(commercial product\))J
126 210 :M
3.22 .322(1. Callbacks: Server records who has copy of file)J
126 246 :M
3.604 .36(2. Write through on close)J
126 264 :M
2.732 .273(     If file changes, server is updated \(on close\))J
126 282 :M
3.066 .307(     Server then immediately tells all those with the old copy.)J
126 318 :M
3.703 .37(3. Session semantics -- updates visible only on close.)J
126 354 :M
4.142 .414(In UNIX \(single machine\), updates visible immediately to other)J
126 372 :M
4.126 .413(programs who have the file open.)J
126 408 :M
3.537 .354(In AFS, everyone who has file open sees old version; anyone)J
126 426 :M
3.544 .354(who opens file again will see new version.)J
126 462 :M
2.083 .208(In AFS:)J
126 480 :M
3.257 .326(a. on open and cache miss: get file from server, set up callback)J
126 498 :M
3.228 .323(b. on write close: send copy to server; tells all clients with)J
126 516 :M
3.78 .378(copies, to fetch new version from server on next open)J
126 552 :M
2.826 .283(4. Files cached on local disk; NFS caches only in memory)J
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(tom; page: 9 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 322 278 rC
43 37 279 109 @f
43 37 380 257 @f
43 37 189 257 @f
275 114 :M
f3_12 sf
(S)S
182 260 :M
(A)S
375 260 :M
(B)S
213.5 94.5 32 34 rS
211 89 :M
(cache)S
44 12 360.5 85.5 @f
44 12 359.5 133.5 @f
-1 -1 338 136 1 1 337 84 @b
-1 -1 382 137 1 1 381 85 @b
244 108 -1 1 259 107 1 244 107 @a
300 107 -1 1 339 106 1 300 106 @a
-1 -1 200 243 1 1 269 124 @b
285 127 -1 1 371 239 1 285 126 @a
311.5 239.5 32 35 rS
342 254 -1 1 357 253 1 342 253 @a
228.5 240.5 32 35 rS
212 259 -1 1 227 258 1 212 258 @a
356 118 :M
-.764(X')A
221 118 :M
-.764(X')A
239 264 :M
-.764(X')A
322 265 :M
(X)S
13 100 148 240 134 @k
-1 -1 184 219 1 1 237 139 @b
174 166 :M
(t=0: X')S
13 210 258 372 221 @k
312 139 -1 1 370 216 1 312 138 @a
13 -84 -36 220 227 @k
-1 -1 224 223 1 1 264 150 @b
240 203 :M
(X' on)S
240 219 :M
( disk)S
145.5 91.5 40 39 rS
136 88 :M
(callback)S
146 114 :M
-.336(X: A,B)A
366 162 :M
(fetch new)S
366 178 :M
(version next )S
366 194 :M
(time X is )S
366 210 :M
(opened)S
44 12 191.5 294.5 @f
44 12 190.5 342.5 @f
-1 -1 169 345 1 1 168 293 @b
-1 -1 213 346 1 1 212 294 @b
187 327 :M
-.764(X')A
44 12 382.5 292.5 @f
44 12 381.5 340.5 @f
-1 -1 360 343 1 1 359 291 @b
-1 -1 404 344 1 1 403 292 @b
378 325 :M
(X)S
gR
gS 30 31 552 730 rC
126 401 :M
f3_12 sf
3.596 .36(What if server crashes?  Lose all your callback state!)J
126 437 :M
4.321 .432(Reconstruct callback information from client -- go ask everyone)J
126 455 :M
3.573 .357("who has which files cached")J
126 491 :M
2.036 .204(AFS pros & cons:)J
126 527 :M
3.061 .306(Relative to NFS, less server load:)J
126 545 :M
2.452 .245(  + disk as cache -> more files can be cached locally)J
126 563 :M
2.974 .297(  + callbacks -> server not involved if file is read-only)J
126 581 :M
3.12 .312(  - on fast LANs, local disk is much slower than remote memory)J
126 617 :M
2.306 .231(In both AFS and NFS:)J
126 653 :M
4.332 .433(Central server is a bottleneck)J
126 671 :M
4.563 .456(  Performance bottleneck:)J
126 689 :M
3.014 .301(    - all data is written through to server)J
126 707 :M
2.426 .243(    - all cache misses go to server)J
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(tom; page: 10 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
4.174 .417(  Availability bottleneck:)J
126 102 :M
2.655 .265(    - server is single point of failure)J
126 120 :M
2.839 .284(  Cost bottleneck:)J
126 138 :M
3.454 .345(    - server machines high cost relative to workstation)J
90 174 :M
f1_14 sf
7.508 .751(22.4 xFS: Serverless Network File Service)J
126 192 :M
f3_12 sf
3.942 .394(Key idea: file system as a parallel program; exploit opportunity)J
126 210 :M
3.891 .389(provided by fast LANs.)J
126 246 :M
3.996 .4(Four key ideas:)J
162 264 :M
5.512 .551(Cooperative caching)J
162 282 :M
5.276 .528(Write ownership cache coherence)J
162 300 :M
3.995 .4(Software RAID)J
162 318 :M
6.112 .611(Distributed control)J
90 354 :M
f1_12 sf
9.117 .912(22.4.1 Cooperative caching)J
126 372 :M
f3_12 sf
3.756 .376(Use remote memory to avoid going to disk \(manage client)J
126 390 :M
4.456 .446(memory as a global shared resource\))J
126 426 :M
3.254 .325(a. on cache miss, get file from someone else's cache instead of)J
126 444 :M
5.36 .536(from disk)J
126 462 :M
3.209 .321(b. on replacement, if last copy of file, send to idle client, instead)J
126 480 :M
5.249 .525(of discarding)J
126 516 :M
4.466 .447(+ better hit rate for read-shared data)J
126 534 :M
3.275 .328(+ active clients get to use memory on idle clients)J
90 570 :M
f1_12 sf
8.427 .843(22.4.2 Write ownership cache coherence)J
126 588 :M
f3_12 sf
3.93 .393(Does server have to get all updates, to keep everything)J
126 606 :M
3.76 .376(consistent?  Answer is no.)J
126 642 :M
3.653 .365(Almost all machines today have disks.  Why write data back to)J
126 660 :M
3.564 .356(the server?  Why not just put them on your local disk?)J
126 696 :M
2.738 .274(Key idea: a machine can "own" a file.  Owner has the most up to)J
126 714 :M
3.196 .32(date copy; no one else has copy.  Server keeps track of who)J
endp
%%Page: 11 11
%%BeginPageSetup
initializepage
(tom; page: 11 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.375 .337("owns" file; any request for the file goes to the server, who)J
126 102 :M
4.579 .458(then forwards to the owner.)J
126 138 :M
.751(Either:)A
126 156 :M
2.251 .225(     One "owned" copy of file \(ex: file you are editing\))J
126 174 :M
3.089 .309(     Multiple "read-only" copies \(ex: emacs executable\))J
126 210 :M
3.109 .311(To modify file, must make sure you have only copy.  Once you)J
126 228 :M
3.442 .344(have only copy, ok to modify multiple times.  If someone else)J
126 246 :M
4.214 .421(reads file, forward the up to date version and mark read-only.)J
126 282 :M
3.334 .333(Each file block in the cache has three states:)J
126 300 :M
1.945 .195(    invalid)J
126 318 :M
2.689 .269(    read-only)J
126 336 :M
3.474 .347(    owned \(read-write\))J
126 339 297 250 rC
56 55 291.5 396 @f
56 55 393.5 521 @f
56 55 196.5 523 @f
273 401 :M
(invalid)S
180 531 :M
(owned)S
375 520 :M
(read)S
375 536 :M
(only)S
13 209 257 385 490 @k
319 404 -1 1 383 485 1 319 403 @a
13 -25 23 224 536 @k
-1 -1 231 537 1 1 363 533 @b
13 107 155 260 408 @k
-1 -1 188 494 1 1 256 412 @b
13 28 76 308 425 @k
312 431 -1 1 371 504 1 312 430 @a
341 422 :M
(read)S
265 533 :M
(write)S
168 426 :M
(write by)S
168 442 :M
(another )S
168 458 :M
-.684(CPU)A
13 -78 -30 217 500 @k
-1 -1 221 496 1 1 274 422 @b
243 470 :M
(write)S
13 155 203 378 545 @k
-1 -1 210 551 1 1 372 545 @b
231 568 :M
(read by another CPU)S
296 464 :M
(write by)S
296 480 :M
(another )S
296 496 :M
-.684(CPU)A
gR
gS 30 31 552 730 rC
139 605 :M
f4_12 sf
-.211(Read file block:)A
139 623 :M
-.211(    if \(invalid\))A
139 641 :M
-.203(      ask server who has up to date version)A
139 659 :M
-.205(      fetch up to date version)A
139 677 :M
-.203(      if any remote machine has it owned:)A
198 695 :M
-.206(on remote machine: read-only)A
139 713 :M
-.204(      on local machine: read-only)A
endp
%%Page: 12 12
%%BeginPageSetup
initializepage
(tom; page: 12 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
139 100 :M
f4_12 sf
-.211(Write file block)A
139 118 :M
-.211(    if \(invalid\))A
139 136 :M
-.203(      ask server who has up to date version,)A
198 154 :M
-.21(and who has copies)A
139 172 :M
-.205(      fetch up to date version)A
139 190 :M
-.207(    else if \(read-only\))A
139 208 :M
-.205(      ask server who has copies)A
139 244 :M
-.204(    if any remote machine has copy:)A
198 262 :M
-.206(on remote machine: invalid)A
139 280 :M
-.206(    on local machine: owned)A
126 312 :M
f3_12 sf
3.598 .36(Example: three CPU's, one server.)J
126 348 :M
7.256 .726(What happens?)J
126 366 :M
2.265 .226(  P1 read A)J
126 384 :M
2.095 .21(  P2 write B)J
126 402 :M
2.265 .226(  P3 read A)J
126 420 :M
2.265 .226(  P1 read A)J
126 438 :M
2.095 .21(  P2 write B)J
126 456 :M
2.347 .235(  P3 write A)J
126 492 :M
3.829 .383(Perfectly ok for that machine to keep modifying the file,)J
126 510 :M
3.814 .381(without telling the server.  For instance, your machine is likely)J
126 528 :M
3.587 .359(to be the only machine with your sub-directory.  You'd like it)J
126 546 :M
3.607 .361(to work if you move to another spot, but why tell the server)J
126 564 :M
3.685 .369(every time you modify a file, just because there is the)J
126 582 :M
4.76 .476(possibility someone might need it elsewhere.)J
90 600 :M
f1_12 sf
6.462 .646(22.4.3  Software RAID)J
126 618 :M
f3_12 sf
3.557 .356(We've made the availability story a whole lot worse.  Now)J
126 636 :M
3.777 .378(pieces of the file system are spread all over everywhere.  If)J
126 654 :M
3.726 .373(any machine in the system goes down, part of the file system)J
126 672 :M
1.056(unavailable.)A
endp
%%Page: 13 13
%%BeginPageSetup
initializepage
(tom; page: 13 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
4.353 .435(xFS solution: stripe data redundantly over multiple disks, using)J
126 102 :M
3.05 .305(software RAID.  Each client writes its modifications to a log)J
126 120 :M
4.555 .455(stored on redundant stripe of disks.)J
126 156 :M
3.919 .392(On failure, others can reconstruct data from the other disks in)J
126 174 :M
3.979 .398(order to figure out missing data.  Logging makes reconstruction)J
126 192 :M
1.141(easy.)A
126 228 :M
2.544 .254(A detail: need to be able to find things on disk.  Done as in LFS)J
126 246 :M
4.179 .418(via an inode/file header map, containing the location of every)J
126 264 :M
3.364 .336(inode on disk.  \(This map is spread over all machines, kept by)J
126 282 :M
4.915 .491(the last writer.\))J
126 318 :M
3.663 .366(Inode map is checkpointed to disk periodically.  On failure,)J
126 336 :M
4.403 .44(read checkpoint from disk, then update from logs written after)J
126 354 :M
.951(checkpoint.)A
90 390 :M
f1_12 sf
9.172 .917(22.4.4 Distributed control)J
126 408 :M
f3_12 sf
3.826 .383(We've decentralized the cache, the disk, writes and reads.  But)J
126 426 :M
3.676 .368(there's still a central server to record who has which copies of)J
126 444 :M
1.253(data.)A
126 480 :M
3.738 .374(xFS solution: spread manager over all machines.  If anyone)J
126 498 :M
3.354 .335(fails, poll clients to know who has what, and then shift its)J
126 516 :M
4.179 .418(responsibilities to a new client.)J
90 552 :M
f1_12 sf
10.899 1.09(22.4.5 Summary)J
126 570 :M
f3_12 sf
3.427 .343(xFS: build large system out of large numbers of small,)J
126 588 :M
7.193 .719(unreliable components.)J
126 624 :M
4.222 .422(Key: everything dynamic -- data, metadata, control can live)J
126 642 :M
3.827 .383(anywhere, on any machine, in any memory, on any location on)J
126 660 :M
3.393 .339(disk.  Also, this means easy to migrate to tape: anything can be)J
126 678 :M
6.971 .697(located anywhere.)J
endp
%%Page: 14 14
%%BeginPageSetup
initializepage
(tom; page: 14 of 14)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
4.665 .466(Started with promise vs. reality of distributed systems: reality)J
126 102 :M
5.234 .523(is lower performance,)J
126 138 :M
3.408 .341(xFS is an example of how distributed systems will look in the)J
126 156 :M
5.122 .512(future: higher performance, higher availability than any)J
126 174 :M
4.633 .463(centralized system.  Improves performance as you add more)J
126 192 :M
3.157 .316(machines: more CPUs, more DRAM, more disks, ought to mean)J
126 210 :M
5.307 .531(better performance, better availability, not worse!)J
126 246 :M
3.692 .369(Also:  automatic reconfiguration.  Machine goes down,)J
126 264 :M
4.167 .417(everything continues to work.  Machine gets added, start using)J
126 282 :M
3.098 .31(its disk and CPU.  \(In hardware, called "hot swap" -- key to)J
126 300 :M
5.81 .581(high availability.\))J
126 336 :M
3.354 .335(Still some challenges: how do you upgrade software to new OS,)J
126 354 :M
2.966 .297(new version of xFS, new version of disk, CPU, etc., while system)J
126 372 :M
4.074 .407(continues to operate?  Can we build systems that operate)J
126 390 :M
4.699 .47(continuously for a decade?)J
endp
%%Trailer
end		% md
%%EOF
