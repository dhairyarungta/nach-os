%!PS-Adobe-3.0
%%Title: (l6)
%%Creator: (Microsoft Word: LaserWriter 8 8.1.1)
%%CreationDate: (8:27 PM Tuesday, February 28, 1995)
%%For: (Robin_Briggs)
%%Pages: 8
%%DocumentFonts: Times-Bold Times-Roman Courier
%%DocumentNeededFonts: Times-Bold Times-Roman Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%ADO_PaperArea: -31 -30 761 582
%ADO_ImageableArea: 0 0 730 552
%%EndComments
/md 141 dict def md begin
/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if
end		% md
%%EndProlog
%%BeginSetup
md begin
countdictstack
[
{%stopped
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *InputSlot Upper

%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *PageRegion LetterSmall
level2 {
		2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
	}{
		/lettersmall where {pop lettersmall} {letterR} ifelse
	} ifelse
%%EndFeature
}featurecleanup
(Robin_Briggs)setjob
/pT[1 0 0 -1 30 761]def/mT[1 0 0 -1 30 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Courier
/f0_1/Times-Bold :mre
/f1_1 f0_1 1.087 scf
/f1_14 f1_1 14 scf
/f1_12 f1_1 12 scf
/f2_1/Times-Roman :mre
/f3_1 f2_1 1.087 scf
/f3_12 f3_1 12 scf
/f4_1/Courier :mre
/f4_12 f4_1 12 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 1 of 8)setjob
%%EndPageSetup
gS 0 0 552 730 rC
60 55 :M
f1_14 sf
7.662 .766(Lecture 6: Implementing Mutual Exclusion)J
60 88 :M
5.878 .588(6.0 Main Point:)J
96 106 :M
f3_12 sf
4.242 .424(How to build higher-level synchronization primitives on top of)J
96 124 :M
6.661 .666(lower-level synchronization primitives.)J
60 160 :M
f1_14 sf
6.021 .602(6.1 The Big Picture)J
96 163 422 199 rC
116 324 :M
f3_12 sf
(Low level)S
116 340 :M
(atomic)S
116 356 :M
(operations)S
115 249 :M
(Higher-level)S
115 265 :M
(atomic)S
115 281 :M
(operations)S
202 336 :M
(load/store)S
202 265 :M
(locks)S
288 336 :M
(interrupt disable)S
428 335 :M
(test&set)S
255 265 :M
(semaphores)S
353 266 :M
(monitors)S
429 265 :M
(send&receive)S
280 197 :M
(concurrent programs)S
-1 -1 198 362 1 1 197 185 @b
116 217 -1 1 514 216 1 116 216 @a
117 295 -1 1 518 294 1 117 294 @a
gR
gS 0 0 552 730 rC
132 392 :M
f1_12 sf
9.74 .974(Relationship among synchronization abstractions)J
96 425 :M
f3_12 sf
4.31 .431(Too much milk example showed that implementing a)J
96 443 :M
4.543 .454(concurrent program directly with loads and stores would be)J
96 461 :M
4.22 .422(tricky and error-prone.  Instead, a programmer is going to)J
96 479 :M
3.708 .371(want to use higher level operations, such as locks.)J
96 515 :M
4.356 .436(Today, how do we implement these higher level operations?)J
96 551 :M
4.44 .444(Next lecture, what higher-level primitives make it easiest to)J
96 569 :M
5.939 .594(write correct concurrent programs?)J
60 605 :M
f1_14 sf
6.981 .698(6.2 Ways of implementing locks)J
96 638 :M
f3_12 sf
4.501 .45(All require some level of hardware support)J
60 674 :M
f1_12 sf
7.017 .702(6.2.1 Atomic memory load and store)J
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 2 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 102 :M
f3_12 sf
3.652 .365(See too much milk lecture!)J
90 135 :M
f1_12 sf
7.375 .738(6.2.2 Directly implement locks and context switches in)J
90 153 :M
1.953(hardware)A
126 186 :M
f3_12 sf
4.387 .439(Implemented in the Intel 432.  Makes hardware slow!)J
90 219 :M
f1_12 sf
8.643 .864(6.2.3 Disable interrupts \(uniprocessor only\))J
126 255 :M
f3_12 sf
3.701 .37(Two ways for dispatcher to get control:)J
126 273 :M
4.262 .426(internal events -- thread does something to relinquish the CPU)J
126 291 :M
4.55 .455(external events -- interrrupts cause dispatcher to take CPU)J
144 309 :M
1.827(away)A
126 345 :M
3.163 .316(On a uniprocessor, an operation will be atomic as long as a)J
126 363 :M
3.674 .367(context switch does not occur in the middle of the operation.)J
126 381 :M
4.498 .45(Need to prevent both internal and external events.  Preventing)J
126 399 :M
4.703 .47(internal events is easy.)J
126 435 :M
4.83 .483(Prevent external events by disabling interrupts, in effect,)J
126 453 :M
4.39 .439(telling the hardware to delay handling of external events until)J
126 471 :M
4.449 .445(after we're done with the atomic operation.)J
90 507 :M
f1_12 sf
10.252 1.025(6.2.3.1 Busy-waiting solution)J
162 526 :M
f4_12 sf
-.216(class Lock {)A
162 544 :M
-.209(   int value = FREE;)A
162 562 :M
(})S
162 598 :M
-.211(Lock::Acquire\(\) {)A
162 616 :M
-.208(   Disable interrupts;)A
162 634 :M
-.206(   while \(value != FREE\) {)A
162 652 :M
-.207(      Enable interrupts;)A
342 652 :M
-.209(// allow interrupts)A
162 670 :M
-.207(      Disable interrupts;)A
162 688 :M
-.231(      })A
162 706 :M
-.211(   value = BUSY;)A
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 3 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
162 82 :M
f4_12 sf
-.208(   Enable interrupts;)A
162 118 :M
-.212(Lock::Release\(\))A
162 136 :M
-.208(   Disable interrupts;)A
162 154 :M
-.211(   value = FREE;)A
162 172 :M
-.208(   Enable interrupts;)A
126 207 :M
f3_12 sf
3.603 .36(Why do we need to disable interrupts at all?  Otherwise, one)J
126 225 :M
3.617 .362(thread could be trying to acquire the lock, and could get)J
126 243 :M
4.496 .45(interrupted between checking and setting the lock value, so)J
126 261 :M
4.024 .402(two threads could think that they both have the lock.)J
126 297 :M
4.414 .441(With disabling interrupts, the check and set operations occur)J
126 315 :M
4.127 .413(without any other thread having the chance to execute in the)J
126 333 :M
1.085(middle.)A
126 369 :M
3.763 .376(Why do we need to enable interrupts inside the loop in)J
126 387 :M
3.915 .391(Acquire?  Otherwise, since interrupts are off, the lock holder)J
126 405 :M
3.273 .327(will never get a chance to run, to release the lock.)J
126 441 :M
3.7 .37(Why might this be a bad solution?)J
126 477 :M
f1_12 sf
1.116(Busy-waiting)A
f3_12 sf
3.704 .37(: thread consumes CPU cycles while it is waiting.)J
126 495 :M
3.551 .355(Not only is this inefficient, it could cause problems if threads)J
126 513 :M
4.437 .444(can have different priorities.  If the busy-waiting thread has)J
126 531 :M
4.093 .409(higher priority than the thread holding the lock, the timer will)J
126 549 :M
3.681 .368(go off, but \(depending on the scheduling policy\), the lower)J
126 567 :M
5.24 .524(priority thread might never run.)J
126 603 :M
3.608 .361(Also, for semaphores and monitors, if not for locks, waiting)J
126 621 :M
3.633 .363(thread may wait for an arbitrary length of time.  Thus, even if)J
126 639 :M
3.375 .337(busy-waiting was OK for locks, it could be very inefficient for)J
126 657 :M
6.546 .655(implementing other primitives.)J
90 693 :M
f1_12 sf
9.617 .962(6.2.3.2 Solution without busy-waiting)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 4 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.729 .373(Waiter gives up the processor so that Release can go forward)J
126 102 :M
5.541 .554(more quickly:)J
162 136 :M
f4_12 sf
-.212(Lock::Acquire\(\))A
162 154 :M
-.208(   Disable interrupts;)A
162 172 :M
-.206(   while \(value != FREE\) {)A
162 190 :M
-.202(         put on queue of threads waiting for lock)A
162 208 :M
-.209(         go to sleep)A
162 226 :M
-.231(      })A
162 244 :M
-.211(   value = BUSY;)A
162 262 :M
-.208(   Enable interrupts;)A
162 298 :M
-.211( Lock::Release\(\))A
162 316 :M
-.207(    Disable interrupts;)A
162 334 :M
-.205(    if anyone on wait queue {)A
198 352 :M
-.206( take a waiting thread off)A
198 370 :M
-.208( put it on ready queue)A
198 388 :M
(})S
162 406 :M
-.211(    value = FREE;)A
162 424 :M
-.208(    Enable interrupts;)A
126 459 :M
f3_12 sf
4.395 .439(When does Acquire re-enable interrupts in going to sleep?)J
126 495 :M
4.322 .432(Before putting the thread on the wait queue?)J
126 513 :M
3.111 .311(    Then Release can check queue, and not wake the thread up.)J
126 549 :M
3.922 .392(After putting the thread on the wait queue, but before going to)J
126 567 :M
1.282(sleep?)A
126 585 :M
3.351 .335(    Then Release puts thread on the ready queue, but thread is)J
126 603 :M
3.603 .36(already on the ready queue!  When thread wakes up, it will go)J
126 621 :M
3.959 .396(to sleep, missing the wakeup from Release.)J
126 657 :M
3.486 .349(To fix this, in Nachos, interrupts are disabled when you call)J
126 675 :M
3.802 .38(Thread::Sleep; it is the responsibility of the next thread to run)J
126 693 :M
6.414 .641(to re-enable interrupts.)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 5 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
4.122 .412(When the sleeping thread wakes up, it returns from Sleep back)J
126 102 :M
3.125 .312(to Acquire.  Interrupts are still disabled, so it's OK to check lock)J
126 120 :M
3.361 .336(value, and if it's free, grab the lock, and then turn on)J
126 138 :M
1.276(interrupts.)A
126 141 315 313 rC
154 213 :M
(Time)S
13 -114 -66 166 295 @k
-1 -1 167 290 1 1 166 221 @b
210 170 :M
(Thread A)S
359 170 :M
(Thread B)S
233 192 :M
(.)S
233 208 :M
(.)S
233 224 :M
(.)S
233 240 :M
(disable)S
233 256 :M
(sleep)S
360 274 :M
(sleep return)S
360 290 :M
(enable)S
360 306 :M
(.)S
360 322 :M
(.)S
360 338 :M
(.)S
360 354 :M
(disable)S
360 370 :M
(sleep)S
224 385 :M
(sleep return)S
224 401 :M
(enable)S
224 417 :M
(.)S
224 433 :M
(.)S
224 449 :M
(.)S
13 165 213 350 265 @k
270 253 -1 1 345 264 1 270 252 @a
295 252 :M
(switch)S
13 -29 19 289 373 @k
-1 -1 296 374 1 1 354 367 @b
295 365 :M
(switch)S
gR
gS 30 31 552 730 rC
126 469 :M
f1_12 sf
7.778 .778(Interrupt disable and enable pattern across context)J
126 487 :M
2.092(switches)A
90 523 :M
7.232 .723(6.2.3.3 A flawed, but very simple solution)J
126 559 :M
f3_12 sf
3.377 .338(Why not do the following:)J
162 596 :M
f4_12 sf
-.203(   Lock::Acquire\(\) { disable interrupts;)A
162 614 :M
(})S
162 632 :M
-.203(   Lock::Release\(\) { enable interrupts; })A
126 667 :M
f3_12 sf
3.208 .321(1. Critical section may be in user code, and you don't want to)J
144 685 :M
3.83 .383(allow user code to disable interrupts \(might never give CPU)J
144 703 :M
3.88 .388(back!\).  In the earlier schemes, the implementation of lock)J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 6 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
144 84 :M
f3_12 sf
4.01 .401(acquire and release would be done in the protected part of)J
144 102 :M
4.357 .436(the operating system, but they could be called by arbitrary)J
144 120 :M
4.805 .481(user code.)J
126 156 :M
3.661 .366(2. Might want to take interrupts during critical section.  For)J
144 174 :M
3.275 .327(instance, what if the lock holder takes a page fault?  Or does)J
144 192 :M
5.459 .546(disk I/O?)J
126 228 :M
4.053 .405(3. Many physical devices depend on real-time constraints.  For)J
144 246 :M
4.086 .409(example, keystrokes can be lost if interrupt for one)J
144 264 :M
4.696 .47(keystroke isn't handled by the time the next keystroke)J
144 282 :M
4.005 .4(occurs.  Thus, want to disable interrupts for the shortest)J
144 300 :M
3.522 .352(time possible.  Critical sections could be very long running.)J
126 336 :M
3.64 .364(4. Simple solution might work for locks, but wouldn't work for)J
144 354 :M
5.425 .543(semaphores or condition variables.)J
90 390 :M
f1_12 sf
10.351 1.035(6.2.4 Atomic read-modify-write instructions)J
126 426 :M
f3_12 sf
4.853 .485(On a multiprocessor, interrupt disable doesn't provide)J
126 444 :M
3.409 .341(atomicity.  It stops context switches from occuring on that CPU,)J
126 462 :M
3.677 .368(but it doesn't stop other CPUs from entering the critical section.)J
126 498 :M
5.533 .553(Instead, every modern processor architecture provides some)J
126 516 :M
4.784 .478(kind of atomic read-modify-write instruction.  These)J
126 534 :M
6.09 .609(instructions )J
f1_12 sf
1.266(atomically)A
f3_12 sf
3.768 .377( read a value from memory into a)J
126 552 :M
4.03 .403(register, and write a new value.  The hardware is responsible)J
126 570 :M
4.358 .436(for implementing this correctly on both uniprocessors \(not too)J
126 588 :M
4.675 .468(hard\) and multiprocessors \(requires special hooks in the)J
126 606 :M
5.755 .575(multiprocessor cache coherence strategy\).)J
126 642 :M
4.011 .401(Unlike disabling interrupts, this can be used on both)J
126 660 :M
6.431 .643(uniprocessors and multiprocessors.)J
90 696 :M
f1_12 sf
9.388 .939(6.2.4.1 Examples of read-modify-write instructions:)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 7 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f1_12 sf
1.278(test&set)A
f3_12 sf
4.144 .414( \(most architectures\) -- read value, write 1 back to)J
144 102 :M
1.707(memory)A
126 120 :M
f1_12 sf
6.45 .645(exchange )J
f3_12 sf
5.069 .507(\(x86\) -- swaps value between register and memory)J
126 138 :M
f1_12 sf
1.56(compare&swap)A
f3_12 sf
4.03 .403( \(68000\) -- read value, if value matches)J
144 156 :M
4.956 .496(register, do exchange)J
126 174 :M
f1_12 sf
5.642 .564(load linked and conditional store )J
f3_12 sf
6.644 .664(\(R4000, Alpha\) --)J
144 192 :M
4.445 .444(designed to fit better with load/store architecture.  Read)J
144 210 :M
4.139 .414(value in one instruction, do some operations, when store)J
144 228 :M
3.509 .351(occurs, check if value has been modified in the meantime.  If)J
144 246 :M
3.169 .317(not, ok.  If it has changed, abort, and jump back to start.)J
90 282 :M
f1_12 sf
8.777 .878(6.2.4.2 Implementing locks with test&set)J
126 318 :M
f3_12 sf
3.597 .36(Test&set reads location, sets it to 1, and returns old value.)J
162 355 :M
f4_12 sf
-.206(Initially, lock value = 0;)A
162 391 :M
-.215(Lock::Acquire)A
162 409 :M
-.203(  while \(test&set\(value\) == 1\) // while)A
162 427 :M
-.264(BUSY)A
162 445 :M
-.231(      ;)A
162 481 :M
-.215(Lock::Release)A
162 499 :M
-.216(  value = 0;)A
126 534 :M
f3_12 sf
2.935 .294(If lock is free, test&set reads 0 and sets value to 1, so lock is)J
126 552 :M
3.151 .315(now busy.  It returns 0, so Acquire completes.  If lock is busy,)J
126 570 :M
3.391 .339(test&set reads 1 and sets value to 1 \(no change\), so lock stays)J
126 588 :M
3.653 .365(busy, and Acquire will loop.)J
126 624 :M
3.667 .367(This is a busy-wait loop, but as with the discussion above about)J
126 642 :M
2.979 .298(disable interrupts, you can modify it to sleep if lock is BUSY.)J
90 675 :M
f1_14 sf
11.967 1.197(6.3 Summary)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 8 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
5.092 .509(Load/store, disabling and enabling interrupts, and atomic read-)J
126 102 :M
4.683 .468(modify-write instructions, are all ways that we can implement)J
126 120 :M
4.91 .491(higher level atomic operations.)J
endp
%%Trailer
end		% md
%%EOF
