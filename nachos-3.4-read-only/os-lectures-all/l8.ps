%!PS-Adobe-3.0
%%Title: (l8)
%%Creator: (Microsoft Word: LaserWriter 8 8.1.1)
%%CreationDate: (8:30 PM Tuesday, February 28, 1995)
%%For: (Robin_Briggs)
%%Pages: 10
%%DocumentFonts: Times-Bold Times-Roman Courier
%%DocumentNeededFonts: Times-Bold Times-Roman Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%ADO_PaperArea: -31 -30 761 582
%ADO_ImageableArea: 0 0 730 552
%%EndComments
/md 120 dict def md begin
/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if
end		% md
%%EndProlog
%%BeginSetup
md begin
countdictstack
[
{%stopped
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *InputSlot Upper

%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *PageRegion LetterSmall
level2 {
		2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
	}{
		/lettersmall where {pop lettersmall} {letterR} ifelse
	} ifelse
%%EndFeature
}featurecleanup
(Robin_Briggs)setjob
/pT[1 0 0 -1 30 761]def/mT[1 0 0 -1 30 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Courier
/f0_1/Times-Bold :mre
/f1_1 f0_1 1.087 scf
/f1_14 f1_1 14 scf
/f1_12 f1_1 12 scf
/f2_1/Times-Roman :mre
/f3_1 f2_1 1.087 scf
/f3_12 f3_1 12 scf
/f4_1/Courier :mre
/f4_12 f4_1 12 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 1 of 10)setjob
%%EndPageSetup
gS 0 0 552 730 rC
60 55 :M
f1_14 sf
6.948 .695(Lecture 8: Monitors, Condition Variables and)J
60 73 :M
1.929(Readers-Writers)A
60 106 :M
6.544 .654(8.0 Main points:)J
96 124 :M
f3_12 sf
4.386 .439(Definition of monitors and condition variables)J
96 142 :M
5.498 .55(Illustrate their use by solving readers-writers problem)J
60 193 :M
f1_14 sf
7.853 .785(8.1 Motivation for monitors)J
96 226 :M
f3_12 sf
3.532 .353(Semaphores are a huge step up; just think of trying to do the)J
96 244 :M
3.943 .394(bounded buffer with only loads and stores.  But problem with)J
96 262 :M
3.925 .392(semaphores is that they are dual purpose.  Used for both mutex)J
96 280 :M
3.863 .386(and scheduling constraints.  This makes the code hard to read,)J
96 298 :M
3.766 .377(and hard to get right.)J
96 334 :M
3.749 .375(Idea in monitors is to separate these concerns: use locks for)J
96 352 :M
4.677 .468(mutual exclusion and condition variables for scheduling)J
96 370 :M
1.021(constraints.)A
60 406 :M
f1_14 sf
7.609 .761(8.2 Monitor Definition)J
96 442 :M
f1_12 sf
1.221(Monitor)A
f3_12 sf
3.361 .336(: a lock and zero or more condition variables for)J
96 460 :M
4.809 .481(managing concurrent access to shared data)J
96 496 :M
4.254 .425(Note: Tanenbaum and Silberschatz both describe monitors as a)J
96 514 :M
4.585 .459(programming language construct, where the monitor lock is)J
96 532 :M
3.44 .344(acquired automatically on calling any procedure in a C++ class,)J
96 550 :M
3.912 .391(for example.  No widely-used language actually does this,)J
96 568 :M
3.586 .359(however!  So in Nachos, and in many real-life operating)J
96 586 :M
3.376 .338(systems, such as Windows NT, OS/2, or Solaris, monitors are)J
96 604 :M
3.772 .377(used with explicit calls to locks and condition variables.)J
60 640 :M
f1_12 sf
8.099 .81(8.2.1 Lock)J
96 658 :M
f3_12 sf
3.366 .337(The )J
f1_12 sf
1.16(lock)A
f3_12 sf
4.161 .416( provides mutual exclusion to the shared data.)J
96 676 :M
1.144(Remember:)A
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 2 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 102 :M
f3_12 sf
3.356 .336(Lock::Acquire -- wait until lock is free, then grab it)J
126 120 :M
3.822 .382(Lock::Release -- unlock, wake up anyone waiting in Acquire)J
126 156 :M
2.727 .273(Rules for using a lock:)J
126 174 :M
4.053 .405(   Always acquire before accessing shared data structure)J
126 192 :M
3.725 .372(   Always release after finishing with shared data.)J
126 210 :M
2.334 .233(   Lock is initially free.)J
126 243 :M
4.313 .431(Simple example: a synchronized list)J
162 277 :M
f4_12 sf
-.213(AddToQueue\(\) {)A
162 295 :M
-.202(  lock.Acquire\(\);  // lock before using shared data)A
162 313 :M
-.202(  put item on queue; // ok to access shared data)A
162 331 :M
-.202(  lock.Release\(\);  // unlock after done with shared)A
306 349 :M
-.231(// data)A
162 367 :M
(})S
162 403 :M
-.209(RemoveFromQueue\(\) {)A
162 421 :M
-.202(  lock.Acquire\(\);   // lock before using shared data)A
162 439 :M
-.202(  if something on queue // ok to access shared data)A
162 457 :M
-.213(    remove it;)A
162 475 :M
-.202(  lock.Release\(\);   // unlock after done with shared)A
306 493 :M
-.231(// data)A
162 511 :M
-.213(  return item;)A
162 529 :M
(})S
90 564 :M
f1_12 sf
8.834 .883(8.2.2 Condition variables)J
126 597 :M
f3_12 sf
3.906 .391(How do we change RemoveFromQueue to wait until something)J
126 615 :M
3.912 .391(is on the queue?)J
126 648 :M
3.008 .301(Logically, want to go to sleep inside of critical section, but if)J
126 666 :M
3.409 .341(hold lock when go to sleep, other threads won't be able to get)J
126 684 :M
3.614 .361(in to add things to the queue, to wake up the sleeping thread.)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 3 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.408 .341(Key idea with condition variables: make it possible to go to)J
126 102 :M
3.868 .387(sleep inside critical section, by )J
f1_12 sf
1.15(atomically)A
f3_12 sf
3.747 .375( releasing lock at)J
126 120 :M
3.359 .336(same time we go to sleep)J
126 153 :M
f1_12 sf
7.899 .79(Condition variable)J
f3_12 sf
4.197 .42(: a queue of threads waiting for something)J
126 171 :M
f1_12 sf
4.637 .464(inside )J
f3_12 sf
5.076 .508(a critical section)J
126 207 :M
5.304 .53(Condition variables support three operations:)J
126 243 :M
2.985 .298(   Wait\(\) -- release lock, go to sleep, re-acquire lock)J
162 261 :M
3.178 .318(Releasing lock and going to sleep is atomic)J
126 297 :M
2.732 .273(   Signal\(\) -- wake up a waiter, if any)J
126 333 :M
3.202 .32(   Broadcast\(\) -- wake up all waiters)J
126 387 :M
4.029 .403(Rule: must hold lock when doing condition variable operations.)J
126 423 :M
3.115 .312(Note: In Birrell paper, he says can do signal outside of lock --)J
126 441 :M
3.223 .322(IGNORE HIM \(this is only a performance optimization, and)J
126 459 :M
3.586 .359(likely to lead you to write incorrect code\).)J
126 495 :M
4.649 .465(A synchronized queue, using condition variables:)J
162 514 :M
f4_12 sf
-.213(AddToQueue\(\) {)A
162 532 :M
-.211(  lock.Acquire\(\);)A
162 550 :M
-.209(  put item on queue;)A
162 568 :M
-.208(  condition.signal\(\);)A
162 586 :M
-.211(  lock.Release\(\);)A
162 604 :M
(})S
162 622 :M
-.209(RemoveFromQueue\(\) {)A
162 640 :M
-.211(  lock.Acquire\(\);)A
162 658 :M
-.207(  while nothing on queue)A
162 676 :M
-.202(     condition.wait\(&lock\);// release lock; go to)A
342 694 :M
-.207(// sleep; re-acquire lock)A
162 712 :M
-.207(  remove item from queue;)A
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 4 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
162 82 :M
f4_12 sf
-.211(  lock.Release\(\);)A
162 100 :M
-.213(  return item;)A
162 118 :M
(})S
90 168 :M
f1_12 sf
6.847 .685(8.2.3 Mesa vs. Hoare monitors)J
126 201 :M
f3_12 sf
3.675 .368(Need to be careful about the precise definition of signal and)J
126 219 :M
1.071(wait.)A
126 255 :M
f1_12 sf
1.183(Mesa-style:)A
f3_12 sf
4.762 .476( \(Nachos, most real operating systems\))J
126 291 :M
2.856 .286(    Signaller keeps lock, processor)J
126 327 :M
3.318 .332(    Waiter simply put on ready queue, with no special priority.)J
126 345 :M
2.946 .295(    \(in other words, waiter may have to wait for lock\))J
126 381 :M
f1_12 sf
7.028 .703(Hoare-style: )J
f3_12 sf
7.899 .79(\(most textbooks\))J
126 417 :M
2.628 .263(    Signaller gives up lock, CPU to waiter; waiter runs)J
126 435 :M
1.28(immediately)A
126 471 :M
3.01 .301(    Waiter gives lock, processor back to signaller when it exits)J
126 489 :M
3.213 .321(critical section or if it waits again.)J
126 525 :M
4.361 .436(Above code for synchronized queuing happens to work with)J
126 543 :M
4.195 .419(either style, but for many programs it matters which you are)J
126 561 :M
3.42 .342(using.  With Hoare-style, can change "while" in)J
126 579 :M
3.764 .376(RemoveFromQueue to an "if", because the waiter only gets)J
126 597 :M
3.542 .354(woken up if item is on the list. With Mesa-style monitors,)J
126 615 :M
4.072 .407(waiter may need to wait again after being)J
126 633 :M
4.484 .448(woken up, because some other thread may have acquired the)J
126 651 :M
4.21 .421(lock, and removed the item, before the original waiting thread)J
126 669 :M
3.732 .373(gets to the front of the ready queue.)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 5 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
4.008 .401(This means as a general principle, you )J
f1_12 sf
7.269 .727(almost always)J
f3_12 sf
3.282 .328( need to)J
126 102 :M
4.198 .42(check the condition after the wait, with Mesa-style monitors \(in)J
126 120 :M
3.163 .316(other words, use a "while" instead of an "if"\).)J
90 153 :M
f1_14 sf
12.863 1.286(8.3 Readers/Writers)J
90 186 :M
f1_12 sf
10.428 1.043(8.3.1 Motivation)J
126 219 :M
f3_12 sf
3.921 .392(  Shared database \(for example, bank balances, or airline seats\))J
126 255 :M
2.54 .254(  Two classes of users:)J
126 273 :M
3.005 .3(      Readers -- never modify database)J
126 291 :M
3.033 .303(      Writers -- read and modify database)J
126 327 :M
3.761 .376(Using a single lock on the database would be overly restrictive.)J
126 345 :M
1.032(Want:)A
126 363 :M
2.721 .272(      many readers at same time)J
126 381 :M
2.488 .249(      only one writer at same time)J
90 417 :M
f1_12 sf
9.787 .979(8.3.2 Constraints)J
126 453 :M
f3_12 sf
4.029 .403(1. Readers can access database when no writers \(Condition)J
144 471 :M
.79(okToRead\))A
126 507 :M
4.209 .421(2. Writers can access database when no readers or writers)J
144 525 :M
5.217 .522(\(Condition okToWrite\))J
126 561 :M
4.021 .402(3. Only one thread manipulates state variables at a time.)J
90 597 :M
f1_12 sf
9.68 .968(8.3.3 Solution)J
126 615 :M
f3_12 sf
4.235 .424(Basic structure of solution)J
162 634 :M
f4_12 sf
-.238(Reader)A
162 652 :M
-.207(  wait until no writers)A
162 670 :M
-.211(  access database)A
162 688 :M
-.204(  check out -- wake up waiting writer)A
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 6 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
162 82 :M
f4_12 sf
-.238(Writer)A
162 100 :M
-.204(  wait until no readers or writers)A
162 118 :M
-.211(  access database)A
162 136 :M
-.202(  check out -- wake up waiting readers or writer)A
126 168 :M
f3_12 sf
5.985 .598(State variables:)J
162 187 :M
f4_12 sf
-.205(  # of active readers -- AR  = 0)A
162 205 :M
-.205(  # of active writers -- AW  = 0)A
162 223 :M
-.204(  # of waiting readers -- WR  = 0)A
162 241 :M
-.204(  # of waiting writers -- WW  = 0)A
162 277 :M
-.206(  Condition okToRead = NIL)A
162 295 :M
-.206(  Condition okToWrite = NIL)A
162 313 :M
-.21(  Lock lock = FREE)A
126 348 :M
f3_12 sf
.21(Code:)A
162 367 :M
f4_12 sf
-.22(Reader\(\) {)A
162 385 :M
-.204(  // first check self into system)A
162 403 :M
-.211(  lock.Acquire\(\);)A
162 421 :M
-.202(  while \(\(AW + WW\) > 0\) {   // check if safe to read)A
162 439 :M
( )S
342 439 :M
-.207(// if any writers, wait)A
162 457 :M
-.223(    WR++;)A
162 475 :M
-.207(    okToRead.Wait\(&lock\);)A
162 493 :M
-.223(    WR--;)A
162 511 :M
-.248(    })A
162 529 :M
-.231(  AR++;)A
162 547 :M
-.211(  lock.Release\(\);)A
162 583 :M
-.218(  Access DB)A
162 619 :M
-.205(  // check self  out of system)A
162 637 :M
-.211(  lock.Acquire\(\);)A
162 655 :M
-.231(  AR--;)A
162 673 :M
-.202(  if \(AR == 0 && WW > 0\)//if no other readers still)A
342 691 :M
-.207(// active, wake up writer)A
162 709 :M
-.206(    okToWrite.Signal\(&lock\);)A
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 7 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
162 82 :M
f4_12 sf
-.211(  lock.Release\(\);)A
162 100 :M
(})S
162 136 :M
-.206(Writer\(\) {   //  symmetrical)A
162 154 :M
-.215(  // check in)A
162 172 :M
-.211(  lock.Acquire\(\);)A
162 190 :M
-.202(  while \(\(AW + AR\) > 0\) { // check if safe to write)A
306 208 :M
-.205(// if any readers or writers,)A
162 226 :M
-.264(wait)A
162 244 :M
-.223(    WW++;)A
162 262 :M
-.206(    okToWrite->Wait\(&lock\);)A
162 280 :M
-.223(    WW--;)A
162 298 :M
-.248(    })A
162 316 :M
-.231(  AW++;)A
162 334 :M
-.211(  lock.Release\(\);)A
162 370 :M
-.218(  Access DB)A
162 406 :M
-.213(  // check out)A
162 424 :M
-.211(  lock.Acquire\(\);)A
162 442 :M
-.231(  AW--;)A
162 460 :M
-.215(  if \(WW > 0\))A
270 460 :M
-.204(// give priority to other writers)A
162 478 :M
-.205(    okToWrite->Signal\(&lock\);)A
162 496 :M
-.21(  else if \(WR > 0\))A
162 514 :M
-.205(    okToRead->Broadcast\(&lock\);)A
162 532 :M
-.211(  lock.Release\(\);)A
162 550 :M
(})S
126 582 :M
f3_12 sf
.69(Questions:)A
126 618 :M
3.332 .333(  1. Can readers starve?)J
126 654 :M
3.058 .306(  2. Why does checkRead need a while?)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 8 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
90 86 :M
f1_14 sf
8.701 .87(8.4 Comparison between semaphores and monitors)J
126 119 :M
f3_12 sf
4.524 .452(Illustrate the differences by considering: can we build monitors)J
126 137 :M
4.245 .424(out of semaphores?  After all, semaphores provide atomic)J
126 155 :M
5.87 .587(operations and queueing.)J
126 191 :M
3.895 .389(Does this work?)J
162 228 :M
f4_12 sf
-.206(Wait\(\) { semaphore->P\(\); })A
162 264 :M
-.206(Signal\(\) { semaphore->V\(\); })A
126 299 :M
f3_12 sf
3.116 .312(Condition variables only work inside of a lock.  If try to use)J
126 317 :M
3.662 .366(semaphores inside of a lock, have to watch for deadlock.)J
126 353 :M
3.895 .389(Does this work?)J
162 390 :M
f4_12 sf
-.21(Wait\(Lock *lock\) {)A
162 408 :M
-.209(   lock->Release\(\);)A
162 426 :M
-.21(   semaphore->P\(\);)A
162 444 :M
-.209(   lock->Acquire\(\);)A
162 462 :M
(})S
162 480 :M
-.22(Signal\(\) {)A
162 498 :M
-.21(   semaphore->V\(\);)A
162 516 :M
(})S
126 551 :M
f3_12 sf
4.391 .439(Condition variables have no history, but semaphores do have)J
126 569 :M
1.073(history.)A
126 605 :M
3.594 .359(What if thread signals and no one is waiting?)J
126 623 :M
.855 .086(      No op.)J
126 641 :M
4.495 .45(What if thread later waits?)J
126 659 :M
1.983 .198(      Thread waits.)J
126 695 :M
3.413 .341(What if thread V's and no one is waiting?)J
126 713 :M
2.175 .217(      Increment.)J
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 9 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.867 .387(What if thread later does P?)J
126 102 :M
2.472 .247(      Decrement and continue.)J
126 138 :M
3.384 .338(In other words, P + V are commutative -- result is the same no)J
126 156 :M
4.077 .408(matter what order they occur.  Condition variables are not)J
126 174 :M
3.689 .369(commutative.  That's why they must be in a critical section --)J
126 192 :M
3.638 .364(need to access state variables to do their job.)J
126 246 :M
3.636 .364(Does this fix the problem?)J
162 283 :M
f4_12 sf
-.22(Signal\(\) {)A
162 301 :M
-.204(   if semaphore queue is not empty)A
198 319 :M
-.212(semaphore->V\(\);)A
162 337 :M
(})S
126 372 :M
f3_12 sf
3.338 .334(For one, not legal to look at contents of semaphore queue. But)J
126 390 :M
3.416 .342(also: race condition -- signaller can slip in after lock is released,)J
126 408 :M
3.93 .393(and before wait.  Then waiter never wakes up!)J
126 444 :M
3.343 .334(Need to release lock and go to sleep atomically.)J
126 480 :M
4.28 .428(Is it possible to implement condition variables using)J
126 498 :M
3.818 .382(semaphores?  Yes, but exercise left to the reader!)J
90 531 :M
f1_14 sf
11.967 1.197(8.5 Summary)J
126 549 :M
f3_12 sf
3.842 .384(Monitors represent the logic of the program -- wait if)J
126 567 :M
3.994 .399(necessary, signal if change something so waiter might need to)J
126 585 :M
5.245 .524(wake up.)J
162 622 :M
f4_12 sf
-.238(  lock)A
162 640 :M
-.208(  while \(need to wait\))A
162 658 :M
-.218(    wait\(\);)A
162 676 :M
-.227(  unlock)A
162 712 :M
-.238(  lock)A
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 10 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
162 82 :M
f4_12 sf
-.204(  do something so no need to wait)A
162 100 :M
-.218(  signal\(\);)A
162 118 :M
-.227(  unlock)A
endp
%%Trailer
end		% md
%%EOF
