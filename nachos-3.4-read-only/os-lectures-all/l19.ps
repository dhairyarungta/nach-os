%!PS-Adobe-3.0
%%Title: (l19)
%%Creator: (Microsoft Word: LaserWriter 8 8.1.1)
%%CreationDate: (0:32 Tuesday, April 25, 1995)
%%For: (tom)
%%Pages: 8
%%DocumentFonts: Times-Bold Times-Roman Courier
%%DocumentNeededFonts: Times-Bold Times-Roman Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%ADO_PaperArea: -31 -30 761 582
%ADO_ImageableArea: 0 0 730 552
%%EndComments
/md 141 dict def md begin
/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if
end		% md
%%EndProlog
%%BeginSetup
md begin
countdictstack
[
{%stopped
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *InputSlot Upper

%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *PageRegion LetterSmall
level2 {
		2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
	}{
		/lettersmall where {pop lettersmall} {letterR} ifelse
	} ifelse
%%EndFeature
}featurecleanup
(tom)setjob
/pT[1 0 0 -1 30 761]def/mT[1 0 0 -1 30 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Courier
/f0_1/Times-Bold :mre
/f1_1 f0_1 1.087 scf
/f1_14 f1_1 14 scf
/f1_12 f1_1 12 scf
/f2_1/Times-Roman :mre
/f3_1 f2_1 1.087 scf
/f3_12 f3_1 12 scf
/f4_1/Courier :mre
/f4_12 f4_1 12 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(tom; page: 1 of 8)setjob
%%EndPageSetup
gS 0 0 552 730 rC
60 55 :M
f1_14 sf
7.767 .777(Lecture 19: Transactions: Reliability from Unreliable)J
60 73 :M
1.889(Components)A
60 91 :M
7.292 .729(19.0 Main Points)J
96 109 :M
f3_12 sf
5.278 .528(Transaction concept: atomicity, durability, serializability)J
96 127 :M
4.505 .45(Write ahead, write behind logging)J
96 145 :M
4.889 .489(Log structured file systems)J
60 181 :M
f1_14 sf
10.717 1.072(19.1 Motivation)J
96 199 :M
f3_12 sf
4.209 .421(File systems have lots of data structures)J
96 217 :M
2.297 .23(    Bitmap of free blocks)J
96 235 :M
1.92 .192(    Directory)J
96 253 :M
2.133 .213(    File header)J
96 271 :M
2.66 .266(    Indirect blocks)J
96 289 :M
1.722 .172(    Data blocks)J
96 325 :M
3.241 .324(For performance, all must be cached!  OK for reads, but what)J
96 343 :M
6.864 .686(about writes?)J
60 397 :M
f1_12 sf
6.423 .642(19.1.1 Modified data kept in memory can be lost)J
96 433 :M
f3_12 sf
4.016 .402(Options for writing data:)J
96 469 :M
f1_12 sf
1.328(Write-through)A
f3_12 sf
4.594 .459(: write change immediately to disk)J
96 487 :M
2.506 .251(       Problem: slow!  Have to wait for write to complete before)J
96 505 :M
2.608 .261(you go on.)J
96 541 :M
f1_12 sf
1.294(Write-back)A
f3_12 sf
3.874 .387(: delay writing modified data back to disk \(for)J
96 559 :M
3.703 .37(example, until replaced\). Problem: can lose data on a crash!)J
60 595 :M
f1_12 sf
9.422 .942(19.1.2 Multiple updates)J
96 613 :M
f3_12 sf
4.657 .466(If multiple updates needed to perform some operation, crash)J
96 631 :M
4.668 .467(can occur between them!)J
96 667 :M
3.864 .386(For example, to move a file between directories:)J
132 685 :M
4.253 .425(delete file from old directory)J
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(tom; page: 2 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
162 84 :M
f3_12 sf
4.03 .403(add file to new directory)J
126 102 :M
3.251 .325(Or create new file:)J
126 120 :M
2.599 .26(      allocate space on disk for header, data)J
126 138 :M
2.498 .25(      write new header to disk)J
126 156 :M
2.433 .243(      add the new file to directory)J
126 192 :M
3.914 .391(What if there's a crash in the middle?  Even with write-through)J
126 210 :M
5.122 .512(can have problems.)J
90 246 :M
f1_14 sf
6.445 .644(19.2 UNIX approach \(ad hoc\))J
126 264 :M
f1_12 sf
1.266(Meta-data)A
f3_12 sf
4.16 .416(: needed to keep file system logically consistent)J
126 282 :M
4.244 .424(\(directories, bitmap, file heades, indirect blocks, etc.\))J
126 300 :M
f1_12 sf
1.305(Data)A
f3_12 sf
3.733 .373(: user bytes)J
90 354 :M
f1_12 sf
10.405 1.04(19.2.1 Meta-data consistency)J
126 372 :M
f3_12 sf
4.335 .433(For meta-data, UNIX uses synchronous write-through.  If)J
126 390 :M
3.944 .394(multiple updates needed, does them in specific order, so that if)J
126 408 :M
3.948 .395(crash, runs special program "fsck" that scans entire disk for)J
126 426 :M
4.16 .416(internal consistency to check for "in progress" operations, and)J
126 444 :M
4.196 .42(then fixes up anything in progress:)J
126 480 :M
4.675 .468(For example:)J
162 498 :M
3.389 .339(file created, but not yet put in any directory => delete file)J
162 516 :M
3.748 .375(blocks allocated, but not in bitmap => update bitmap)J
90 552 :M
f1_12 sf
8.399 .84(19.2.2 User data consistency)J
126 570 :M
f3_12 sf
3.706 .371(What about user data?  Write back, forced to disk every 30)J
126 588 :M
3.461 .346(seconds \(or user can call "sync" to force to disk immediately\).)J
126 624 :M
3.836 .384(No guarantee blocks are written to disk in any order.)J
126 678 :M
4.772 .477(However, sometimes meta-data consistency is good enough.)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(tom; page: 3 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.441 .344(For example, how should vi or emacs write save changes to a)J
126 102 :M
3.569 .357(file to disk?)J
162 138 :M
3.91 .391(delete old file)J
162 156 :M
4.417 .442(write new file)J
126 192 :M
3.095 .309(How vi used to work!)J
126 246 :M
3.118 .312(Now vi does the following:)J
162 264 :M
4.072 .407(write new version in temp file)J
162 282 :M
3.828 .383(move old version to other temp file)J
162 300 :M
3.922 .392(move new version into real file)J
162 318 :M
4.886 .489(unlink old version)J
126 354 :M
3.343 .334(If crash, look at temp area; if any files out there, send e-mail to)J
126 372 :M
4.236 .424(user that there might be a problem.)J
126 408 :M
3.701 .37(But what if user wants to have multiple file operations occur as)J
126 426 :M
3.391 .339(a unit?  Example: Bank transfer -- ATM gives you $100, debits)J
126 444 :M
3.978 .398(it from your account.)J
90 480 :M
f1_14 sf
7.453 .745(19.3  Transaction Concept)J
126 516 :M
f1_12 sf
1.259(Transactions)A
f3_12 sf
3.939 .394(: group actions together so that they are:)J
126 552 :M
f1_12 sf
1.42(Atomic)A
f3_12 sf
4.203 .42(: either happens or it doesn't \(no partial operations\))J
126 588 :M
f1_12 sf
1.23(Serializable)A
f3_12 sf
4.567 .457(: transactions appear to happen one after the)J
126 606 :M
1.55(other)A
126 642 :M
f1_12 sf
1.292(Durable)A
f3_12 sf
4.201 .42(: once it happens, stays happened)J
126 696 :M
4.071 .407(Critical sections are atomic and serializable, not durable.)J
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(tom; page: 4 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
4.463 .446(Two more terms:)J
126 102 :M
3.772 .377(  Commit -- when transaction is done \(durable\))J
126 120 :M
3.522 .352(  Rollback -- if failure during a transaction \(means it didn't)J
126 138 :M
4.551 .455(happen at all\))J
126 174 :M
1.084(Metaphor:)A
126 192 :M
2.788 .279(  Do a set of operations tentatively.  If get to commit, ok.)J
126 210 :M
3.443 .344(  If not, roll back the operations as if the transaction never)J
126 228 :M
1.345(happened.)A
90 282 :M
f1_14 sf
9.461 .946(19.4 Transaction Implementation \(one thread\))J
126 300 :M
f3_12 sf
3.574 .357(Key idea: fix problem of how you make multiple updates to)J
126 318 :M
4.117 .412(disk atomically, by turning multiple updates into a single disk)J
126 336 :M
1.173(write!)A
126 372 :M
4.329 .433(Illustrate with simple money transfer, from account x to)J
126 390 :M
4.419 .442(account y.)J
162 427 :M
f4_12 sf
-.211(Begin transaction)A
162 445 :M
-.216(  x = x + 1;)A
162 463 :M
-.216(  y = y - 1;)A
162 481 :M
-.238(Commit)A
126 534 :M
f3_12 sf
3.196 .32(Keep "write-ahead" \(or "redo"\) log on disk of all changes in)J
126 552 :M
3.329 .333(transaction.  A log is like a journal -- never erased, record of)J
126 570 :M
3.526 .353(everything you've done.  Once both changes are on log,)J
126 588 :M
3.913 .391(transaction is committed.  Then can "write behind" changes to)J
126 606 :M
3.802 .38(disk -- if crash after commit, replay log to make sure updates)J
126 624 :M
3.353 .335(get to disk.)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(tom; page: 5 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 362 231 rC
68 14 360.5 102.5 @f
68 14 360.5 196.5 @f
-1 -1 328 195 1 1 327 102 @b
-1 -1 396 197 1 1 395 104 @b
171.5 118.5 75 59 rS
169 111 :M
f3_12 sf
(Memory cache)S
336 131 :M
(X: 0)S
336 170 :M
(Y: 2)S
182 141 :M
(X: 0)S
183 169 :M
(Y: 2)S
320.5 227.5 132 35 rS
333 91 :M
(Disk)S
308 282 :M
(Write-ahead log \(on disk or )S
308 298 :M
(tape or non-volatile RAM\))S
325 252 :M
-.148(X=1)A
-1 -1 387 263 1 1 386 226 @b
353 251 :M
(Y = 1)S
-1 -1 352 264 1 1 351 227 @b
394 254 :M
(commit)S
gR
gS 30 31 552 730 rC
126 336 :M
f3_12 sf
4.328 .433(Sequence of steps to execute transaction:)J
162 355 :M
f4_12 sf
-.205(  1. write new value of x to log)A
162 373 :M
-.205(  2. write new value of y to log)A
162 391 :M
-.211(  3. write commit)A
162 409 :M
-.209(  4. write x to disk)A
162 427 :M
-.209(  5. write y to disk)A
162 445 :M
-.207(  6. reclaim space on log)A
126 480 :M
f3_12 sf
2.989 .299(What if we crash after 1?  No commit, nothing on disk, so just)J
126 498 :M
5.479 .548(ignore changes.)J
126 534 :M
2.938 .294(What if we crash after 2?  Ditto.)J
126 570 :M
3.031 .303(What if we crash after 3 before 4 or 5?  Commit written to log,)J
126 588 :M
3.744 .374(so replay those changes back to disk.)J
126 624 :M
3.3 .33(What if we crash while we are writing "commit?"  As with)J
126 642 :M
4.515 .451(concurrency, need some primitive atomic operation, or else)J
126 660 :M
3.426 .343(can't build anything.  Writing a single sector on disk \(with a)J
126 678 :M
1.324 .132(CRC\) is atomic!)J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(tom; page: 6 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
2.973 .297(Can we write x back to disk before commit?  Yes: keep an)J
126 102 :M
3.394 .339("undo log": save old value along with new value.  If transaction)J
126 120 :M
4.355 .436(doesn't commit, "undo" change!)J
90 156 :M
f1_14 sf
6.796 .68(19.5 Two phase locking)J
126 174 :M
f3_12 sf
4.167 .417(What if two threads run same transaction at the same time?)J
126 210 :M
3.062 .306(Concurrency => use locks)J
162 247 :M
f4_12 sf
-.211(Begin transaction)A
162 265 :M
-.218(  Lock x, y)A
162 283 :M
-.215(    x = x + 1)A
162 301 :M
-.215(    y = y - 1)A
162 319 :M
-.215(  Unlock x, y)A
162 337 :M
-.231( Commit)A
126 372 :M
f3_12 sf
2.895 .29(What if A grabs locks, modifies x, y, writes to the log, unlocks,)J
126 390 :M
3.587 .359(and right before commiting, then B comes in, grabs lock, writes)J
126 408 :M
3.083 .308(x, y, unlocks, does commit.  Then before A commits, crash!)J
126 444 :M
3.061 .306(Problem is: B commits values for x, y, that depend on A)J
126 462 :M
.913(commiting.)A
126 498 :M
3.62 .362(Solution: two-phase locking.  First phase, only allowed to)J
126 516 :M
3.559 .356(acquire locks.  All unlocks happen at commit.)J
126 552 :M
3.04 .304(Thus, B can't see any of A's changes, until A commits and)J
126 570 :M
3.827 .383(releases locks.   This provides serializability!)J
90 606 :M
f1_14 sf
8.027 .803(19.6 Transactions in file systems)J
90 642 :M
f1_12 sf
9.781 .978(19.6.1 Write-ahead logging)J
126 660 :M
f3_12 sf
3.804 .38(Almost all file systems built since 1985 use write ahead logging)J
126 678 :M
2.29 .229(\(Windows NT, Solaris, OSF, etc\).   Write all changes in a)J
126 696 :M
4.059 .406(transaction to log \(update directory, allocate block, etc.\), before)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(tom; page: 7 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.158 .316(sending any changes to the disk.  "Create file", "delete file",)J
126 102 :M
4.438 .444("move file" are transactions.)J
126 138 :M
3.911 .391(This eliminates any need for file system check \(fsck\) after)J
126 156 :M
1.029(crash!)A
126 192 :M
3.339 .334(If crash, read log:)J
126 210 :M
2.812 .281(  If log isn't complete, no change!)J
126 228 :M
3.194 .319(  If log is completely written, apply all changes to disk)J
126 246 :M
2.954 .295(  If log is zero, then all updates have gotten to disk.)J
126 282 :M
1.098(Advantage:)A
126 300 :M
2.534 .253(  + reliability)J
126 318 :M
4.447 .445(  + asynchronous write-behind)J
126 336 :M
3.193 .319(  - all data written twice)J
90 390 :M
f1_12 sf
9.483 .948(19.6.2 Log-structured file systems)J
126 408 :M
f3_12 sf
3.827 .383(Log-structured file systems: idea is to write data only once, by)J
126 426 :M
3.231 .323(having the log be the only copy of the data.)J
126 444 :M
3.343 .334(As you modify disk blocks, just store them out to disk in the)J
126 462 :M
3.132 .313(log.  Put everything: data blocks, file header, etc. on log.)J
126 516 :M
3.233 .323(If need to get data from disk, get it from the log -- keep map)J
126 534 :M
4.046 .405(in memory to tell you where everything is \(for crash recovery,)J
126 552 :M
3.052 .305(have to put map on log too\).)J
126 588 :M
3.74 .374(Advantages: all writes are sequential!  No seeks, except for)J
126 606 :M
3.285 .328(reads.  But)J
126 624 :M
2.345 .235(    RAM is getting cheaper => Caches getting bigger.)J
126 642 :M
2.685 .268(    In extreme case \(infinite size caches\) -> disk I/O only for )J
162 660 :M
4.288 .429(writes \(only for durability of data\))J
126 696 :M
3.141 .314( Thus, optimize for writes!  Logging does that.)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(tom; page: 8 of 8)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.604 .36(Eventually, wrap around.  Run out of room.  What happens?)J
126 102 :M
3.172 .317(Have to garbage collect.  Majority of files deleted in the first 5)J
126 120 :M
3.235 .324(minutes.  So go back over log, and compress pieces that are no)J
126 138 :M
3.172 .317(longer  in use.  If disk fills up, need to clean more frequently,)J
126 156 :M
5.06 .506(so keep disk under-utilized.)J
126 192 :M
2.456 .246(Pros & cons:)J
126 210 :M
2.73 .273(    + write performance)J
126 228 :M
3.107 .311(    + reads, if file written sequentially from beginning to end)J
126 246 :M
2.607 .261(    - cleaning cost \(off-line?\))J
126 264 :M
2.612 .261(    - bad if files are updated in place)J
endp
%%Trailer
end		% md
%%EOF
