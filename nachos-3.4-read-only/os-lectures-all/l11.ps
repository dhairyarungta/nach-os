%!PS-Adobe-3.0
%%Title: (l11)
%%Creator: (Microsoft Word: LaserWriter 8 8.1.1)
%%CreationDate: (8:17 PM Tuesday, February 28, 1995)
%%For: (Robin_Briggs)
%%Pages: 10
%%DocumentFonts: Times-Bold Times-Roman
%%DocumentNeededFonts: Times-Bold Times-Roman
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%ADO_PaperArea: -31 -30 761 582
%ADO_ImageableArea: 0 0 730 552
%%EndComments
/md 139 dict def md begin
/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if
end		% md
%%EndProlog
%%BeginSetup
md begin
countdictstack
[
{%stopped
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *InputSlot Upper

%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *PageRegion LetterSmall
level2 {
		2 dict dup /PageSize [612 792] put dup /ImagingBBox null put setpagedevice
	}{
		/lettersmall where {pop lettersmall} {letterR} ifelse
	} ifelse
%%EndFeature
}featurecleanup
(Robin_Briggs)setjob
/pT[1 0 0 -1 30 761]def/mT[1 0 0 -1 30 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
/f0_1/Times-Bold :mre
/f1_1 f0_1 1.087 scf
/f1_14 f1_1 14 scf
/f1_12 f1_1 12 scf
/f2_1/Times-Roman :mre
/f3_1 f2_1 1.087 scf
/f3_12 f3_1 12 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 1 of 10)setjob
%%EndPageSetup
gS 0 0 552 730 rC
60 55 :M
f1_14 sf
7.176 .718(Lecture 11: CPU Scheduling)J
60 91 :M
7.292 .729(11.0 Main Points)J
96 109 :M
f3_12 sf
4.204 .42(Scheduling policy goals)J
96 127 :M
4.781 .478(Policy options)J
96 145 :M
8.372 .837(Implementation considerations)J
96 181 :M
3.952 .395(Earlier, said dispatcher can choose any thread on the ready list)J
96 199 :M
2.407 .241(to run.   But how is OS to decide, when it has a choice?)J
60 253 :M
f1_14 sf
7.746 .775(11.1 Scheduling Policy Goals)J
96 289 :M
f3_12 sf
2.292 .229(1. )J
f1_12 sf
7.211 .721(Minimize response time)J
f3_12 sf
4.228 .423(: elapsed time to do an operation)J
114 307 :M
3.839 .384(\(or job\))J
96 325 :M
2.891 .289(     Response time is what the user sees: elapsed time to)J
132 343 :M
4.195 .42(echo a keystroke in editor)J
96 361 :M
.704 .07(  )J
132 361 :M
4.858 .486(compile a program)J
96 379 :M
.687 .069(    )J
132 379 :M
4.268 .427(run a large scientific problem)J
96 415 :M
2.065 .206(2. )J
f1_12 sf
8.663 .866(Maximize throughput)J
f3_12 sf
4.227 .423(: operations \(or jobs\) per second)J
96 433 :M
3.936 .394(  \(Throughput is related to response time, but they're not)J
96 451 :M
.972(identical\))A
96 487 :M
4.795 .479(Two parts to maximizing throughput)J
96 505 :M
.908 .091(    a. )J
f1_12 sf
8.138 .814(Minimize overhead)J
f3_12 sf
4.921 .492( \(for example, context switching\))J
96 523 :M
1.096 .11(    b. )J
f1_12 sf
5.918 .592(Efficient use of system resources)J
f3_12 sf
4.235 .424( \(not only CPU, but)J
96 541 :M
4.459 .446(disk, memory, etc.\))J
96 577 :M
1.699 .17(3. )J
f1_12 sf
1.012(Fair)A
f3_12 sf
3.443 .344(: share CPU among users in some equitable way)J
96 613 :M
4.995 .499(What does fairness mean?)J
96 649 :M
3.719 .372(Minimize average response time?  We will argue fairness is a)J
96 667 :M
4.712 .471(tradeoff against average response time; can get better average)J
96 685 :M
4.655 .465(response time by making system )J
f1_12 sf
1.063(less)A
f3_12 sf
3.566 .357( fair.)J
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 2 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
90 86 :M
f1_14 sf
13.147 1.315(11.2 Assumptions)J
126 104 :M
f3_12 sf
3.431 .343(Bunch of algorithms for CPU scheduling -- big area of research)J
126 122 :M
3.903 .39(in the early 70's.)J
126 158 :M
5.718 .572(These assume:)J
126 176 :M
3.564 .356(  one program per user)J
126 194 :M
3.896 .39(  one thread per program)J
126 212 :M
4.774 .477(  programs are independent)J
126 248 :M
3.482 .348(Clearly, these are unrealistic.  Simplify problem so it can be)J
126 266 :M
3.541 .354(solved.  Open issue is: what happens if you remove these)J
126 284 :M
1.155(constraints?)A
90 320 :M
f1_14 sf
9.237 .924(10.3 Scheduling policies:)J
90 356 :M
f1_12 sf
6.987 .699(10.3.1 FIFO)J
126 374 :M
f3_12 sf
4.073 .407(Different names for the same thing:)J
162 392 :M
3.138 .314(FCFS -- first come first serve)J
126 410 :M
.704 .07(  )J
162 410 :M
2.925 .292(FIFO -- first in first out)J
126 428 :M
.704 .07(  )J
162 428 :M
4.079 .408(Run until done)J
126 464 :M
3.449 .345(In early systems, FIFO meant, one program kept CPU until it)J
126 482 :M
4.163 .416(completely finished.  With strict uniprogramming, if have to)J
126 500 :M
4.088 .409(wait for I/O, keep processor.)J
126 536 :M
3.219 .322(Later, FIFO just means, keep CPU until thread blocks \(this is)J
126 554 :M
4.917 .492(what I'll assume\).)J
126 590 :M
3.06 .306(FIFO pros&cons:)J
126 608 :M
2.265 .227( + simple)J
126 626 :M
3.265 .326( - short jobs get stuck behind long jobs)J
90 680 :M
f1_12 sf
7.327 .733(10.3.2 Round Robin)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 3 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 84 :M
f3_12 sf
3.8 .38(Solution?  Add timer, and preempt CPU from long-running jobs.)J
126 102 :M
4.295 .43(Just about every real operating system does something of this)J
126 120 :M
.933(flavor.)A
126 156 :M
f1_12 sf
1.331(Round-robin)A
f3_12 sf
3.448 .345(: after time slice, move thread to back of the)J
126 174 :M
1.714(queue)A
126 192 :M
3.043 .304(In some sense, it's fair -- each job gets equal shot at the CPU.)J
90 228 :M
f1_12 sf
6.691 .669(10.3.2.1 How do you choose time slice?)J
126 264 :M
f3_12 sf
2.889 .289(1\) What if too big?)J
162 282 :M
5.206 .521(Response time suffers)J
126 318 :M
3.194 .319(2\) What if too small?)J
126 336 :M
3.266 .327(    Throughput suffers.  Spend all your time context switching,)J
126 354 :M
2.826 .283(    none getting real work done.)J
126 390 :M
3.541 .354(In practice, need to balance these two.  Typical time slice today)J
126 408 :M
3.862 .386(is between 10-100 milliseconds; typical timeslice is 0.1 - 1)J
126 426 :M
.807(millisecond,)A
126 444 :M
3.876 .388(so roughly 1% overhead due to time-slicing.)J
90 480 :M
f1_12 sf
6.602 .66(10.3.2.2 Comparison between FIFO and Round Robin)J
126 516 :M
f3_12 sf
3.474 .347(Assuming zero-cost time slice, is RR always better than FIFO?)J
126 534 :M
3.05 .305(For example: 10 jobs, each take 100 seconds of CPU time.)J
126 552 :M
3.086 .309(Round Robin time slice of1 second.  All start at the same time:)J
249 588 :M
f1_12 sf
8.183 .818(Job completion times)J
160 606 :M
f3_12 sf
2.928 .293(Job #)J
306 606 :M
-.087(FIFO)A
425 606 :M
4.03 .403(Round Robin)J
170 624 :M
2.015 .202( 1)J
306 624 :M
3.979 .398( 100)J
452 624 :M
2.217(991)A
170 642 :M
2.015 .202( 2)J
306 642 :M
3.979 .398( 200)J
452 642 :M
2.217(992)A
169 660 :M
( ...)S
311 660 :M
.289 .029(  ...)J
459 660 :M
-.392(...)A
170 678 :M
2.015 .202( 9)J
306 678 :M
3.979 .398( 900)J
452 678 :M
2.217(999)A
168 696 :M
2.956(10)A
304 696 :M
1.971(1000)A
448 696 :M
1.971(1000)A
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 4 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 102 :M
f3_12 sf
3.569 .357(Round robin runs one second from each job, before going back)J
126 120 :M
2.888 .289(to the first.  So each job accumulates 99 seconds of CPU time)J
126 138 :M
6.106 .611(before any)J
126 156 :M
.839(finish.)A
126 192 :M
3.399 .34(Both round robin and FIFO finish at the same time, but)J
126 210 :M
f1_12 sf
5.473 .547(average )J
f3_12 sf
4.401 .44(response time is much worse under RR than under)J
126 228 :M
-.13(FIFO.)A
126 264 :M
4.347 .435(Thus, round robin pros&cons:)J
126 282 :M
3.099 .31( + better for short jobs)J
126 300 :M
3.491 .349( - poor when jobs are same length)J
90 336 :M
f1_12 sf
6.313 .631(10.3.3 STCF/SRTCF)J
126 372 :M
1.414(STCF)A
f3_12 sf
3.206 .321(: shortest time to completion first.  Run whatever job has)J
126 390 :M
3.435 .343(the least amount of stuff to do.)J
126 426 :M
f1_12 sf
1.344(SRTCF)A
f3_12 sf
3.487 .349(: shortest remaining time to completion first.)J
126 444 :M
3.579 .358(Preemptive version of STCF -- if job arrives that has a shorter)J
126 462 :M
4.042 .404(time to completion than the remaining time on the current job,)J
126 480 :M
3.613 .361(immediately preempt CPU to give to new job.)J
126 516 :M
3.042 .304(Idea is get short jobs out of the system.  Big effect on short)J
126 534 :M
3.262 .326(jobs, small effect on short jobs.  Result is better )J
f1_12 sf
1.428(average)A
126 552 :M
f3_12 sf
6.783 .678(response time)J
126 606 :M
2.795 .279(In fact, STCF/SRTCF are the best you can possibly do, at)J
126 624 :M
4.167 .417(minimizing average response time \(STCF among non-)J
126 642 :M
3.629 .363(preemptive policies, SRTCF among preemptive policies\).  Can)J
126 660 :M
2.948 .295(prove they're optimal.  Since SRTCF is always at least as good as)J
126 678 :M
.472 .047(STCF, focus on SRTCF.)J
90 714 :M
f1_12 sf
5.225 .522(10.3.3.1 Comparison of SRTCF with FIFO and Round Robin)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 5 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 102 :M
f3_12 sf
3.033 .303(What if all jobs are the same length?  SRTCF becomes the same)J
126 120 :M
2.34 .234(as FIFO \(in other words, FIFO is as good as you can do if all jobs)J
126 138 :M
4.472 .447(are the same length\).)J
126 174 :M
3.266 .327(What if jobs have varying length?  SRTCF \(and round robin\):)J
126 192 :M
3.686 .369(short jobs don't get stuck behind long jobs.)J
126 228 :M
3.176 .318(Example to illustrate the benefits of SRTCF:)J
126 264 :M
4.482 .448(Three jobs:)J
126 282 :M
2.784 .278(A, B: both CPU bound, infinite length)J
126 300 :M
2.649 .265(C: I/O bound, loop)J
162 318 :M
1.561 .156(1 ms of CPU)J
162 336 :M
3.162 .316(10 ms of disk I/O)J
126 372 :M
2.28 .228(By itself, C uses 90% of the disk; by itself, A or B could use)J
126 390 :M
3.056 .306(100% of the CPU.  What happens if we try to share system)J
126 408 :M
2.634 .263(between A, B, and C?)J
126 444 :M
1.986 .199(With FIFO:)J
162 462 :M
2.42 .242(once A or B get in, keep CPU forever.)J
126 498 :M
3.281 .328(With Round Robin \(100 ms time slice\):)J
162 516 :M
3.405 .341(only get 5% disk utilization)J
126 552 :M
3.036 .304(With Round Robin \(1 ms time slice\):)J
162 570 :M
2.971 .297(Get nearly 90% disk utilization -- almost as good as C)J
126 588 :M
.898(alone.)A
126 606 :M
3.068 .307(But we haven't slowed A or B by all that much: they still get)J
126 624 :M
2.74 .274(90% of the CPU.  \(Lots of wakeups, however!\))J
126 660 :M
2.999 .3(With SRTCF: no needless preemptions \(run C as soon as)J
126 678 :M
3.417 .342(possible, run either A or B to completion\))J
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 6 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 323 362 rC
140 121 -1 1 442 120 1 140 120 @a
-1 -1 140 136 1 1 139 97 @b
-1 -1 385 141 1 1 384 102 @b
-1 -1 381 141 1 1 380 102 @b
-1 -1 262 136 1 1 261 97 @b
-1 -1 144 136 1 1 143 97 @b
137 89 :M
f3_12 sf
(C)S
188 89 :M
(A)S
309 89 :M
(B)S
380 98 :M
(C)S
432 88 :M
(A)S
142 244 -1 1 444 243 1 142 243 @a
-1 -1 143 259 1 1 142 220 @b
-1 -1 148 259 1 1 147 220 @b
139 212 :M
(C)S
217 167 :M
(RR, 100 ms time slice)S
235 290 :M
(RR, 1 ms time slice)S
-1 -1 154 258 1 1 153 219 @b
-1 -1 159 258 1 1 158 219 @b
144 212 :M
(A)S
152 212 :M
(B)S
-1 -1 165 258 1 1 164 219 @b
158 213 :M
(A)S
166 213 :M
(B)S
-1 -1 171 257 1 1 170 218 @b
177 241 :M
-.522(..)A
-1 -1 188 262 1 1 187 223 @b
-1 -1 193 262 1 1 192 223 @b
184 215 :M
(C)S
-1 -1 199 261 1 1 198 222 @b
189 215 :M
(A)S
13 156 204 186 264 @k
147 265 -1 1 181 264 1 147 264 @a
149 284 :M
(C's I/O)S
147 365 -1 1 449 364 1 147 364 @a
-1 -1 149 382 1 1 148 343 @b
-1 -1 155 382 1 1 154 343 @b
146 339 :M
(C)S
163 340 :M
(A)S
-1 -1 194 383 1 1 193 344 @b
-1 -1 200 383 1 1 199 344 @b
191 340 :M
(C)S
208 341 :M
(A)S
-1 -1 237 385 1 1 236 346 @b
-1 -1 243 385 1 1 242 346 @b
234 342 :M
(C)S
251 343 :M
(A)S
13 156 204 183 140 @k
144 141 -1 1 178 140 1 144 140 @a
146 160 :M
(C's I/O)S
13 156 204 193 386 @k
154 387 -1 1 188 386 1 154 386 @a
156 406 :M
(C's I/O)S
229 429 :M
-.718(SRCTF)A
gR
gS 30 31 552 730 rC
131 449 :M
f1_12 sf
4.737 .474(Effect of RR time quanta and SRTCF on I/O bound jobs)J
126 485 :M
f3_12 sf
2.547 .255(A downside to SRTCF is that it can lead to starvation.   Lots of)J
126 503 :M
3.779 .378(short jobs can keep long jobs from making any progress.)J
126 539 :M
1.893 .189(SRTCF pros&cons:)J
126 557 :M
3.637 .364(  + optimal \(average response time\))J
126 575 :M
3.457 .346(  - hard to predict the future)J
126 593 :M
2.753 .275(  - unfair)J
90 629 :M
f1_12 sf
8.225 .823(10.3.3.2 Knowledge of future)J
126 647 :M
f3_12 sf
3.747 .375(Problem: STCF/SRTCF require knowledge of the future.)J
126 683 :M
3.348 .335(How do you know how long program will run for?)J
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 7 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 102 :M
f3_12 sf
3.698 .37(Some systems ask the user:when you submit a job like a)J
126 120 :M
3.139 .314(compile, have to say how long it will take.)J
126 174 :M
3.3 .33(To stop cheating,  if your job takes more than what you said,)J
126 192 :M
3.249 .325(system kills your job.  Start all over.  Like with the Banker's)J
126 210 :M
4.05 .405(algorithm -- hard to predict  resource usage in advance.)J
126 246 :M
3.759 .376(Instead, can't really know how long things will take, but can)J
126 264 :M
3.125 .312(use SRTCF as a yardstick, for measuring other policies.  Optimal,)J
126 282 :M
3.896 .39(so can't do any better than that!)J
90 318 :M
f1_12 sf
10.085 1.008(10.3.4 Multilevel feedback)J
126 354 :M
f3_12 sf
3.38 .338(Central idea in computer science \(occurs in lots of places\): )J
f1_12 sf
1.593(use)A
126 372 :M
5.495 .549(past to predict future)J
f3_12 sf
3.921 .392(.  If program was I/O bound in past,)J
126 390 :M
3.588 .359(likely to be in future.)J
126 408 :M
4.123 .412(If computer behavior was random, induction wouldn't help.  Or)J
126 426 :M
4.32 .432(if past behavior was opposite of current behavior.)J
126 462 :M
3.283 .328(But program behavior is regular, most of the time.  How do we)J
126 480 :M
4.35 .435(exploit this?  If past behavior predicts future behavior, then)J
126 498 :M
3.302 .33(favor jobs that have been at CPU least amount of time, to)J
126 516 :M
3.828 .383(approximate SRTCF!)J
126 552 :M
f1_12 sf
5.35 .535(Adaptive )J
f3_12 sf
3.984 .398(policies: change policy based on past behavior.  Used)J
126 570 :M
3.371 .337(in CPU scheduling, in virtual memory, in file systems, etc.)J
126 606 :M
f1_12 sf
7.34 .734(Multi-level feedback queues)J
f3_12 sf
4.1 .41( \(first used in CTSS, example of)J
126 624 :M
3.851 .385(an adaptive policy for CPU scheduling\): multiple queues, each)J
126 642 :M
3.787 .379(with different priority.  OS does round robin at each priority)J
126 660 :M
3.822 .382(level -- run highest priority jobs first; once those finish, run)J
126 678 :M
3.765 .376(next highest priority, etc.  Round robin time slice increases)J
126 696 :M
5.201 .52(exponentially at lower priorities.)J
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 8 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 72 318 174 rC
163 94 -1 1 224 93 1 163 93 @a
-1 -1 224 115 1 1 223 93 @b
165 115 -1 1 224 114 1 165 114 @a
-1 -1 166 115 1 1 165 114 @b
165 115 -1 1 224 114 1 165 114 @a
-1 -1 224 115 1 1 223 93 @b
163 94 -1 1 224 93 1 163 93 @a
25 23 245 104 @f
298 89 :M
f3_12 sf
(Priority)S
312 111 :M
(1)S
312 149 :M
(2)S
313 192 :M
(3)S
312 236 :M
(4)S
376 89 :M
(Time Slice)S
402 112 :M
(1)S
405 145 :M
(2)S
405 193 :M
(4)S
403 238 :M
(8)S
164 139 -1 1 225 138 1 164 138 @a
-1 -1 225 160 1 1 224 138 @b
166 160 -1 1 225 159 1 166 159 @a
-1 -1 167 160 1 1 166 159 @b
166 160 -1 1 225 159 1 166 159 @a
-1 -1 225 160 1 1 224 138 @b
164 139 -1 1 225 138 1 164 138 @a
25 21 248 148 @f
166 185 -1 1 227 184 1 166 184 @a
-1 -1 227 206 1 1 226 184 @b
168 206 -1 1 227 205 1 168 205 @a
-1 -1 169 206 1 1 168 205 @b
168 206 -1 1 227 205 1 168 205 @a
-1 -1 227 206 1 1 226 184 @b
166 185 -1 1 227 184 1 166 184 @a
25 21 250 194 @f
165 225 -1 1 226 224 1 165 224 @a
-1 -1 226 246 1 1 225 224 @b
167 246 -1 1 226 245 1 167 245 @a
-1 -1 168 246 1 1 167 245 @b
167 246 -1 1 226 245 1 167 245 @a
-1 -1 226 246 1 1 225 224 @b
165 225 -1 1 226 224 1 165 224 @a
25 21 249 234 @f
gR
gS 30 31 552 730 rC
225 261 :M
f1_12 sf
10.13 1.013(Multilevel feedback queues)J
126 297 :M
f3_12 sf
3.999 .4(Adjust each job's priority as follows \(details vary\):)J
162 315 :M
4.006 .401(1. Job starts in highest priority queue.)J
126 333 :M
.684 .068(     )J
162 333 :M
3.761 .376(2. If timeout expires, drop one level)J
162 351 :M
3.495 .35(3. If timeout doesn't expire, push up one level \(or back to)J
126 369 :M
1.33(top\))A
126 405 :M
2.915 .292(Result approximates SRTCF: CPU bound jobs drop like a rock,)J
126 423 :M
4.499 .45(while short-running I/O bound jobs stay near top.)J
126 459 :M
3.527 .353(Multilevel feedback queues \(like SRTCF\) are still unfair: long)J
126 477 :M
3.531 .353(running jobs may never get the CPU.)J
126 531 :M
f1_12 sf
1.276(Countermeasure)A
f3_12 sf
3.097 .31(: user action that can foil intent of the OS)J
126 549 :M
4.434 .443(designer.  For multilevel feedback, countermeasure would be to)J
126 567 :M
3.23 .323(put in meaningless I/O to keep job's priority high.  Of course, if)J
126 585 :M
4.742 .474(everyone did this, wouldn't work!)J
90 639 :M
f1_12 sf
9.644 .964(10.3.5 Lottery scheduling)J
126 657 :M
f3_12 sf
3.076 .308(What should we do about fairness?  Since SRTCF is optimal and)J
126 675 :M
3.767 .377(unfair, any increase in fairness \(for instance by giving long jobs)J
126 693 :M
3.429 .343(a fraction of the CPU, even when there are shorter jobs to run\))J
126 711 :M
4.318 .432(will have to hurt average response time.)J
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 9 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 120 :M
f3_12 sf
4.444 .444(How do we implement fairness?)J
126 156 :M
2.993 .299(Could give each queue a fraction of the CPU, but this isn't)J
126 174 :M
3.725 .372(always fair.  What if there's one long-running job, and 100)J
126 192 :M
7.873 .787(short-running ones?)J
126 228 :M
3.695 .369(Could adjust priorities: increase priority of jobs, as they )J
f1_12 sf
1.366(don't)A
126 246 :M
f3_12 sf
2.709 .271(get service.  This is what's done in UNIX.)J
126 282 :M
3.559 .356(Problem is that this is ad hoc - what rate should you increase)J
126 300 :M
3.358 .336(priorities?  And, as system gets overloaded, no job gets CPU)J
126 318 :M
3.756 .376(time, so everyone increases in priority.  The result is that)J
126 336 :M
3.841 .384(interactive jobs suffer -- both short )J
f1_12 sf
1.428(and)A
f3_12 sf
3.654 .365( long jobs have high)J
126 354 :M
1.067(priority!)A
126 390 :M
5.403 .54(Instead, )J
f1_12 sf
6.228 .623(lottery scheduling: )J
f3_12 sf
4.845 .484(give every job some number of)J
126 408 :M
3.8 .38(lottery tickets, and on each time slice, randomly pick a winning)J
126 426 :M
2.991 .299(ticket.  On average, CPU time is proportional to # of tickets)J
126 444 :M
3.249 .325(given to each job.)J
126 480 :M
3.011 .301(How do you assign tickets?  To approximate SRTCF, short)J
126 498 :M
3.351 .335(running jobs get more, long running jobs get fewer.  To avoid)J
126 516 :M
4.085 .409(starvation, every job gets at least one ticket \(so everyone)J
126 534 :M
6.654 .665(makes progress\).)J
126 570 :M
4.972 .497(Major advantage over strict priority scheduling: behaves)J
126 588 :M
3.3 .33(gracefully as load changes.  Adding or deleting a job affects all)J
126 606 :M
4.528 .453(jobs proportionately, independent of how many tickets each job)J
126 624 :M
3.006 .301(has.  For example, if short jobs get 10 tickets, and long jobs get)J
126 642 :M
3.663 .366(1 each, then:)J
126 678 :M
3.778 .378(# short jobs /)J
126 696 :M
3.008 .301(# long jobs)J
270 678 :M
1.008 .101(% of CPU each)J
270 696 :M
4.157 .416(short job gets)J
414 678 :M
1.008 .101(% of CPU each)J
414 696 :M
3.316 .332(long job gets)J
126 714 :M
3.166(1/1)A
270 714 :M
.547(91%)A
414 714 :M
-.385(9%)A
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(Robin_Briggs; page: 10 of 10)setjob
%%EndPageSetup
-30 -31 :T
gS 30 31 552 730 rC
126 87 :M
f3_12 sf
3.166(0/2)A
270 87 :M
.166(NA)A
414 87 :M
.547(50%)A
126 105 :M
3.166(2/0)A
270 105 :M
.547(50%)A
414 105 :M
.166(NA)A
126 123 :M
2.603(10/1)A
270 123 :M
.547(10%)A
414 123 :M
-.385(1%)A
126 141 :M
2.603(1/10)A
270 141 :M
.547(50%)A
414 141 :M
-.385(5%)A
endp
%%Trailer
end		% md
%%EOF
